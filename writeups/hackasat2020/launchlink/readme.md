## Payload - LaunchLink

### Background

> Satellite Internet brought to you by Launchdotcom, first generation prototype, ahead of its time. We've managed to download an early prototype of their payload module. Our team of reverse engineers have analyzed the prototype and developed a suitable emulator for executing the binary firmware extracted from the device. We've included the Emulator and Reverse Engineering notes from our analysis.

Provided files are in rfmagic.zip. The challenge binary is `challenge.rom` which is little-endian MIPS32. A simulator `vmips` is provided but has some of its debugging functionality disabled.

### Analysis

As this is a MIPS binary, we cannot use our favorite tool, Hex-Rays, though this may change in the future. Instead, we used Ghidra for most of the reversing and bug hunting.

Using your preferred reverse engineering tool, open the binary with a base address of 0xBFC00000. Additionally, you want to map some RAM at 0xA0000000. Thankfully, the simulator is kind enough to tell us the memory mapping for the hardware peripherals:

```
Mapping ROM image (challenge.rom, 10019 words) to physical address 0x1fc00000
Mapping RAM module (host=..., 2048KB) to physical address 0x0
Mapping Timer device to physical address 0x01010000
Connected IRQ7 to the Timer device
Mapping Flag Device to physical address 0x02008000
Mapping Synova UART to physical address 0x02000000
Connected IRQ3 to the Synova UART
Mapping Synova UART to physical address 0x02000010
Connected IRQ4 to the Synova UART
Connected IRQ5 to the Synova UART
```

At `BFC004D4`, we can see a loop that copies the data section from ROM to RAM. It is useful to do the same operation ourselves so that string references will work. If you are using IDA Pro, you can run something like:

```
ida_bytes.patch_bytes(0xA0180000, ida_bytes.get_bytes(0xBFC08EF8, 0x9C8C - 0x8EF8))
```

The main function initializes some structures then runs a main loop with three tasks: MAC, RLL (radio link layer), and RRL (radio resource layer). It ticks each of these tasks once per loop.

The MAC layer is what we communicate with, and the MAC layer encapsulates data into a message that gets sent to the RLL. The RLL will decrypt (if appropriate) and send the data to the RRL. The RRL processes the command, and sends a response back through the RLL (which encrypts) and MAC layer.

There are a bunch of debug messages that are disabled by default. While we are analysing the binary, we can binary patch it to enable these messages by changing the instruction at BFC08E10 from `move $a0, $zero` to `addiu $a0, $zero, 0xf`.

Also, while the debugging features of `vmips` did not seem to work, the halt handler does still work if you provide the `haltdumpcpu` option. We can insert a BREAK instruction with a binary patch at any point where we want to see what the registers currently look like. 

### Solution

First, we need to be able to talk to the binary. This requires understanding that the MAC layer packets have a 3 byte header: type, CRC-16 of data. There are two primary MAC packet types: 0x79 (change block size), and 0xe3 (data packet).

By default, each MAC packet is exactly 32 bytes. By sending a change block size packet, we can increase this up to 192 bytes. This will be important because the upper layers may require us to send larger packets.

The MAC layer sends the data from a data packet to the RLL. This data starts with the packet type. Packet type 0x17 is for initiating the key exchange, and packet type 0x73 is used for data. Packet type 0x73 cannot be sent until the key exchange has been initiated because it needs to decrypt the data using the session key.

The key exchange takes the data we send plus some random data generated by the server, and generates a session key that is used to encrypt and decrypt messages. Because the "random" data is the same on every boot due to the lack of any real RNG, we chose to completely ignore this code and instead used the encryption key and IVs that are printed by the debugging messages.

The RLL data packets have a header of: type (0x73), last bit, sequence number (11 bits), and fragment number (4 bits). These bit fields are arranged as `last||seq||frag`. The data is reassembled and sent to the next layer when a packet with the last bit is set. Fragments from 0 to N are concatenated in order.

The RRL processes the data and sends back responses. The logic is essentially: create a thing, print a thing, and delete a thing.

There is a fair amount of logic in both the RLL and RRL which could contain a vulnerability. The vulnerability that we exploited was in the reassembly functionality in the RLL.

As described previously, the fragment number field is 4 bits, so the reassembly supports up to 16 fragments. Each fragment can have a size up to 192 bytes - 6 header bytes. The max possible size is 2976 bytes which would trivially overflow the reassembly buffer size of 1280 bytes. To prevent this, the reassemble function will first check that the total reassembled size does not overflow the buffer:

```
uint reassemble_length(int st)
{
  uint uVar1;
  uint uVar2;
  int iVar3;

  uVar1 = 0;
  uVar2 = 0;
  iVar3 = 4;
  do {
    iVar3 = *(int *)(st + iVar3 * 4);
    if (iVar3 != 0) {
      uVar1 = uVar1 + *(byte *)(iVar3 + 4) & 0xffff;
    }
    uVar2 = uVar2 + 1 & 0xff;
    iVar3 = uVar2 + 4;
  } while (uVar2 <= *(byte *)(st + 0x52));
  return uVar1;
}

undefined4 do_reassemble(int st,int buf,uint bufsz,undefined2 *actualsz)
{
  uint uVar1;
  undefined4 uVar2;
  undefined4 *puVar3;
  int *piVar4;
  int iVar5;

  uVar1 = reassemble_length();
  uVar2 = 0;
  if (uVar1 <= bufsz) {
    piVar4 = (int *)(st + 0x10);
    iVar5 = 0;
    do {
      puVar3 = (undefined4 *)*piVar4;
      if (puVar3 != (undefined4 *)0x0) {
        memcpy(buf + iVar5,*puVar3,(uint)*(byte *)(puVar3 + 1));
        iVar5 = iVar5 + (uint)*(byte *)(*piVar4 + 4);
      }
      piVar4 = piVar4 + 1;
      uVar2 = 1;
    } while (piVar4 != (int *)(st + 0x50));
    *actualsz = (short)iVar5;
  }
  return uVar2;
}
```

However, we eventually noticed that there is a subtle difference in these two functions. Whereas `reassemble_length` iterates up to and including the last fragment, `do_reassemble` will iterate over all present fragments. This means that if we can send 15 fragments with fragment number 1 - 15, then send a "last" fragment with number 0. `reassemble_length` will think that the total size is much smaller (only one block size instead of sixteen block sizes).

Now, we have a trivial stack buffer overflow that gives us the ability to execute a ROP gadget. Our stated goal is to read the flag from the device at 0xa2008000. Since we are not on Linux, we cannot simply call puts to get the flag sent back. Instead, we need to use the same UART device as the MAC layer and make sure it does not crash before we get the flag.

Luckily, there is convenient code in the MAC process for us to send data over the UART. At `BFC084BC`, we have something like:

```
jal     malloc_
move    $a0, $s4
...
move    $a2, $s2
move    $a1, $s0
move    $a0, $t0
...
jal     memcpy
nop
lw      $a0, 0x30($s1)
move    $a1, $s3
jal     uart_transmit
move    $a2, $s4
```

This code copies data from `$s0` into a new buffer then transmits it over the UART. We just have to set `$s0` to `0xa2008000`, and the other registers appropriately. We also set up the stack so that after the data is queued in the UART buffer, we infinitely loop so that it does not crash before the interrupt handler transmits the entire flag.

A working exploit with some comments can be found in `solve.py` which requires python3 and pwntools.
