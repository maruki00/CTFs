## DartS - Reversing Challenge - Writeup by Robert Xiao (@nneonneo)

### Description

DartS is a binary compiled using the new Dart programming language from Google. It needs to be run using the Dart runtime. We are also provided with a packet capture showing a bunch of UDP packets that were generated by the binary (presumably the encoded form of the flag).

### Solution

The Dart runtime includes a sophisticated runtime debugger which can be accessed through a web browser (although it only works on Chrome). The runtime debugger allows you to step through the binary in the Dart VM, and also to view the code for any function. In the provided binary, the code seems to have already been compiled to x86-64 assembly, so that's what we have to reverse engineer.

Luckily, the "unoptimized" assembly is actually fairly easy to work with. Function calls are annotated by the Dart debugger, and everything is a function call (including simple things like adding two numbers). All arguments are passed on the stack, and arguments are cleaned by the caller, making it straightforward to determine the inputs to any given function. A bunch of manual reversing produced the pseudocode found in [darts.code](darts.code).

From looking at this code, we can see that the function takes the flag as input as an array of bytes, then generates 100 outputs each as long as the flag. Each output is sent to a particular UDP port. The crucial function is `Y9u8Iu.l75g4v`:

```
v28 = 0;
for(v30 = this.gaeym7.length - 1; v30 >= 0; v30--) {
    v28 = e5v35l(zhl9i7(v28, arg), this.gaeym7[v30]);
}
return v28;
```

`this.gaeym7` is an array that contains a single flag byte followed by 99 random bytes. `zhl9i7` refers to two global tables, `fjke0l` and `sfyc9a`. A quick search online shows that these tables are exponentiation and log tables respectively for Rijndael's finite field (the Galois field GF(2<sup>8</sup>) over x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1), meaning that the function `zhl9i7` performs a multiplication over this field. Similarly, `e5v35l` is the addition operation (it just XORs its inputs). Thus, what `Y9u8Iu.l75g4v` does is evaluate a polynomial defined by `this.gaeym7`, with coefficients drawn from GF(2^8). 1 random polynomial is generated per flag byte. Each polynomial is of degree 100, and is evaluated at 100 random points (the UDP port numbers). Thus, we can recover the polynomials using Lagrange interpolation - see [decode.sage](decode.sage) for the SAGE code that implements this. Run it, and get the nice flag:

    TWCTF{dart_iS_Still_alive!_Shamir'S_Secret_Sharing_with_dart_SnapShot}
