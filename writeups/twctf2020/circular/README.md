We are given Ruby code and a server.

Examining `keygen.rb`, we can see a secure 2048-bit modulus along with a 2048-bit `k` value.
```
p = OpenSSL::BN.generate_prime(1024)
q = OpenSSL::BN.generate_prime(1024)
k = OpenSSL::BN.generate_prime(2048, false)
n = p * q
File.write("pubkey.txt", { n: n.to_s, k: k.to_s }.to_json)
```

`app.rb` contains the actual encryption code:
```
EXPECTED_MESSAGE = 'SUNSHINE RHYTHM'
...
x = data["x"].to_i
y = data["y"].to_i
msg = data["msg"].to_s
hash = ""
4.times do |i|
  hash += Digest::SHA512.hexdigest(msg + i.to_s)
end
hash = hash.to_i(16) % n
signature = (x ** 2 + k * y ** 2) % n

if signature == hash
  if msg == EXPECTED_MESSAGE
    return { result: ENV["FLAG"] }
```

We need to provide a `x` and `y` value such that `(x**2 + k*y**2) % n` evaluates to a hash.

The hash is generated by taking the SHA512 hash of a fixed message modified slighly at the end each time and appending it throughout. This isn't reversible in any case, so we can just focus on the end result hash and ignore the hashing process.

We can find an algorithm to solve equations of the form `(x**2 + k*y**2) = m % n` in this paper by Pollard and Schnorr [here](https://ieeexplore.ieee.org/document/1057350/).

Implementing this, we can use given `n`,`k`,`hash` values to get a valid `x` and `y` for the server and get the flag: `TWCTF{dbodfs-dbqsjdpso-mjcsb-mfp}`