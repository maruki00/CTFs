from string import printable
from tqdm import tqdm

assert (3/2)*2 == 3, 'use python3'

p = 168144747387516592781620466787069575171940752179672411574452734808497653671359884981272746489813635225263167370526619987842319278446075098036112998679570069486935297242638675590736039429506131690941660748942375274820626186241210376537247501823653926524570571499198040207829317830442983944747691656715907048411
q = 84072373693758296390810233393534787585970376089836205787226367404248826835679942490636373244906817612631583685263309993921159639223037549018056499339785034743467648621319337795368019714753065845470830374471187637410313093120605188268623750911826963262285285749599020103914658915221491972373845828357953524205
g = 2
h = 98640592922797107093071054876006959817165651265269454302952482363998333376245900760045606011965672215605936345612030149799453733708430421685495677502147392514542499678987737269487279698863617849581626352877756515435930907093553607392143564985566046429416461073375036461770604488387110385404233515192951025299

with open('./ciphertext.txt', 'r') as f:
    ct = list(map(eval, f.read().strip().split('\n')))


assert q == 3 * 5 * 19 * 5710354319 * 51658928397640816749496741258372813990722627656855754562391398098921970341107502745503897286522726230109424976175433646991098836185027283530688300614255822120936368467861662197207684132094740490803687878442773882280113279254839084462283459148390201062466564601191314219384110976101430980883391327


ident_primes = [2, 3, 5, 19]


def res(x, a):
    assert a in ident_primes
    return pow(x, (p-1)//a, p)


rev = {}
for ch in tqdm(printable, desc="Preparing reverse lookup table"):
    ident = tuple(pow(ord(ch), (p-1)//n, p) for n in ident_primes)
    if ident not in rev:
        rev[ident] = []
    rev[ident] += [ch]


known_reference_c1 = ct[0][0]
known_reference_c2 = ct[0][1]
known_reference_m = ord('T') # flag should start with 'TWCTF{'
known_reference_minv = pow(known_reference_m, p-2, p)


results = []

for c1, c2 in tqdm(ct, desc="Analyzing ciphertexts"):

    ident = []

    for a in ident_primes:

        known_c1_res = res(known_reference_c1, a)
        known_c2minv_res = res(known_reference_c2 * known_reference_minv, a)
        c1_res = res(c1, a)
        c2_res = res(c2, a)

        b = next(i for i in range(a) if pow(known_c1_res, i, p) == c1_res)
        assert b is not None

        aux_known_c2_res = pow(known_c2minv_res, b, p)
        inv = pow(aux_known_c2_res, p-2, p)

        finres = (c2_res * inv) % p

        ident += [finres]

    ident = tuple(ident)
    if ident in rev:
        results += [rev[ident]]
    else:
        results += [None]


print(results)
